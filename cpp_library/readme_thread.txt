1.多线程的并发问题
在两个线程对a进行自增的过程中可能会因为线程调度的问题使得最终结果并不正确。
比如当前a的值为1，线程x现在将a的值读到寄存器中，而线程y也将a读到寄存器中，完成了自增并将新的值放入内存中，现在a的值为2，
而线程x现在也对寄存器中的值进行自增，并将得到的结果放入内存中，a的值为2。

可以看到两个线程都对a进行了自增，但是却得到的错误的结果。
这种情况便需要对线程间进行同步。

2. C++11的线程间同步方式
2.1 互斥锁
mutex _mutex;
_mutex.lock();//加锁
_mutex.unlock();//解锁
_mutex.try_lock();//尝试加锁，成功返回bool，失败返回false不阻塞

2.2 自旋锁
自旋锁是一种忙等形式的锁，会在用户态不停的询问，锁是否可以获取，不会陷入到内核态中，所以更加高效。
缺点是可能会对CPU资源造成浪费。
但是在C++11中并没有直接提供自旋锁的实现，但可以借助原子操作实现简单的自旋锁。

atomic_flag是一个原子变量，共有set和clear两种状态。
在clear状态下test_and_set会将其状态置于set并返回false，在set状态下test_and_set会返回true。
可以看到自旋锁其实和CAS方式实现的乐观锁很相似，使用原子操作改变标志为的值，并不断地轮询标志位。

2.3 条件变量
应用如：实现多线程顺序打印

现在我们使用C++11的条件变量完成三个线程顺序打印0，1，2：

std::atomic<int> 是 C++11 引入的一个原子类型，
它允许在多线程环境中对整数进行原子操作，
即这些操作在执行过程中不会被其他线程打断。
原子操作通常用于同步和并发编程，以避免数据竞争和其他并发问题

2.4 屏障
barrier是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都达到一点，然后从该点继续执行；
可以使用条件变量和互斥锁完成屏障的功能

就是说，自定义一个wait函数，在该函数中使用条件变量的wait等待通知的到来。一旦通知到来，说明所有的工作都完成。

而发出通知的函数，和该等待函数，使用同一个互斥量，即unique_lock<mutex> lock(mutex_);， 
同时在该函数中，进行相关的计数操作，直到该计数操作符合一定条件时，发出通知；

