// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#include "test.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CLayerRef::CLayerRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CLayerRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CLayerRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CLayerRefDefaultTypeInternal() {}
  union {
    CLayerRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CLayerRefDefaultTypeInternal _CLayerRef_default_instance_;
PROTOBUF_CONSTEXPR CColor::CColor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.r_)*/0u
  , /*decltype(_impl_.g_)*/0u
  , /*decltype(_impl_.b_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CColorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CColorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CColorDefaultTypeInternal() {}
  union {
    CColor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CColorDefaultTypeInternal _CColor_default_instance_;
PROTOBUF_CONSTEXPR CEntryColor::CEntryColor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CEntryColorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CEntryColorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CEntryColorDefaultTypeInternal() {}
  union {
    CEntryColor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CEntryColorDefaultTypeInternal _CEntryColor_default_instance_;
PROTOBUF_CONSTEXPR CDictionaryColor::CDictionaryColor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entry_color_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CDictionaryColorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDictionaryColorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDictionaryColorDefaultTypeInternal() {}
  union {
    CDictionaryColor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDictionaryColorDefaultTypeInternal _CDictionaryColor_default_instance_;
PROTOBUF_CONSTEXPR CContent::CContent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layerref_)*/{}
  , /*decltype(_impl_.dictionarycolor_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CContentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CContentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CContentDefaultTypeInternal() {}
  union {
    CContent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CContentDefaultTypeInternal _CContent_default_instance_;
PROTOBUF_CONSTEXPR CProperty::CProperty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unit_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CPropertyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPropertyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPropertyDefaultTypeInternal() {}
  union {
    CProperty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPropertyDefaultTypeInternal _CProperty_default_instance_;
PROTOBUF_CONSTEXPR CGeneral::CGeneral(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.property_)*/nullptr
  , /*decltype(_impl_.general_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGeneralDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGeneralDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGeneralDefaultTypeInternal() {}
  union {
    CGeneral _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGeneralDefaultTypeInternal _CGeneral_default_instance_;
PROTOBUF_CONSTEXPR CSpec::CSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.general_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSpecDefaultTypeInternal() {}
  union {
    CSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSpecDefaultTypeInternal _CSpec_default_instance_;
PROTOBUF_CONSTEXPR CCadHeader::CCadHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spec_)*/{}
  , /*decltype(_impl_.units_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CCadHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCadHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCadHeaderDefaultTypeInternal() {}
  union {
    CCadHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCadHeaderDefaultTypeInternal _CCadHeader_default_instance_;
PROTOBUF_CONSTEXPR CLayer::CLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.polarity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.side_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.layerfunction_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CLayerDefaultTypeInternal() {}
  union {
    CLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CLayerDefaultTypeInternal _CLayer_default_instance_;
PROTOBUF_CONSTEXPR CSpecRef::CSpecRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSpecRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSpecRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSpecRefDefaultTypeInternal() {}
  union {
    CSpecRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSpecRefDefaultTypeInternal _CSpecRef_default_instance_;
PROTOBUF_CONSTEXPR CStackupLayer::CStackupLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layerorgroupref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.specref_)*/nullptr
  , /*decltype(_impl_.tominus_)*/0
  , /*decltype(_impl_.toplus_)*/0
  , /*decltype(_impl_.sequence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CStackupLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CStackupLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CStackupLayerDefaultTypeInternal() {}
  union {
    CStackupLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CStackupLayerDefaultTypeInternal _CStackupLayer_default_instance_;
PROTOBUF_CONSTEXPR CStackupGroup::CStackupGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stackup_layer_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tominus_)*/0
  , /*decltype(_impl_.toplus_)*/0
  , /*decltype(_impl_.overalltickness_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CStackupGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CStackupGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CStackupGroupDefaultTypeInternal() {}
  union {
    CStackupGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CStackupGroupDefaultTypeInternal _CStackupGroup_default_instance_;
PROTOBUF_CONSTEXPR CStackup::CStackup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.wheremeasured_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stackupgroup_)*/nullptr
  , /*decltype(_impl_.tominus_)*/0
  , /*decltype(_impl_.toplus_)*/0
  , /*decltype(_impl_.overalltickness_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CStackupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CStackupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CStackupDefaultTypeInternal() {}
  union {
    CStackup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CStackupDefaultTypeInternal _CStackup_default_instance_;
PROTOBUF_CONSTEXPR CCadData::CCadData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layer_)*/{}
  , /*decltype(_impl_.stackup_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CCadDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCadDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCadDataDefaultTypeInternal() {}
  union {
    CCadData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCadDataDefaultTypeInternal _CCadData_default_instance_;
PROTOBUF_CONSTEXPR CEcad::CEcad(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cadheader_)*/nullptr
  , /*decltype(_impl_.caddata_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CEcadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CEcadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CEcadDefaultTypeInternal() {}
  union {
    CEcad _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CEcadDefaultTypeInternal _CEcad_default_instance_;
PROTOBUF_CONSTEXPR root::root(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/nullptr
  , /*decltype(_impl_.ecad_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct rootDefaultTypeInternal {
  PROTOBUF_CONSTEXPR rootDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~rootDefaultTypeInternal() {}
  union {
    root _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 rootDefaultTypeInternal _root_default_instance_;
static ::_pb::Metadata file_level_metadata_test_2eproto[17];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_test_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_test_2eproto = nullptr;

const uint32_t TableStruct_test_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CLayerRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CLayerRef, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CColor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CColor, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::CColor, _impl_.g_),
  PROTOBUF_FIELD_OFFSET(::CColor, _impl_.b_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CEntryColor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CEntryColor, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CEntryColor, _impl_.color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDictionaryColor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDictionaryColor, _impl_.entry_color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CContent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContent, _impl_.layerref_),
  PROTOBUF_FIELD_OFFSET(::CContent, _impl_.dictionarycolor_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CProperty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CProperty, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::CProperty, _impl_.unit_),
  PROTOBUF_FIELD_OFFSET(::CProperty, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGeneral, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGeneral, _impl_.general_),
  PROTOBUF_FIELD_OFFSET(::CGeneral, _impl_.property_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSpec, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSpec, _impl_.general_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CCadHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCadHeader, _impl_.units_),
  PROTOBUF_FIELD_OFFSET(::CCadHeader, _impl_.spec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CLayer, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CLayer, _impl_.polarity_),
  PROTOBUF_FIELD_OFFSET(::CLayer, _impl_.side_),
  PROTOBUF_FIELD_OFFSET(::CLayer, _impl_.layerfunction_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSpecRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSpecRef, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _impl_.tominus_),
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _impl_.toplus_),
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _impl_.layerorgroupref_),
  PROTOBUF_FIELD_OFFSET(::CStackupLayer, _impl_.specref_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _impl_.tominus_),
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _impl_.toplus_),
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _impl_.overalltickness_),
  PROTOBUF_FIELD_OFFSET(::CStackupGroup, _impl_.stackup_layer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStackup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.wheremeasured_),
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.tominus_),
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.toplus_),
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.overalltickness_),
  PROTOBUF_FIELD_OFFSET(::CStackup, _impl_.stackupgroup_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CCadData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCadData, _impl_.layer_),
  PROTOBUF_FIELD_OFFSET(::CCadData, _impl_.stackup_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CEcad, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CEcad, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CEcad, _impl_.cadheader_),
  PROTOBUF_FIELD_OFFSET(::CEcad, _impl_.caddata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::root, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::root, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::root, _impl_.content_),
  PROTOBUF_FIELD_OFFSET(::root, _impl_.ecad_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::CLayerRef)},
  { 7, -1, -1, sizeof(::CColor)},
  { 16, -1, -1, sizeof(::CEntryColor)},
  { 24, -1, -1, sizeof(::CDictionaryColor)},
  { 31, -1, -1, sizeof(::CContent)},
  { 39, -1, -1, sizeof(::CProperty)},
  { 48, -1, -1, sizeof(::CGeneral)},
  { 56, -1, -1, sizeof(::CSpec)},
  { 64, -1, -1, sizeof(::CCadHeader)},
  { 72, -1, -1, sizeof(::CLayer)},
  { 82, -1, -1, sizeof(::CSpecRef)},
  { 89, -1, -1, sizeof(::CStackupLayer)},
  { 100, -1, -1, sizeof(::CStackupGroup)},
  { 111, -1, -1, sizeof(::CStackup)},
  { 123, -1, -1, sizeof(::CCadData)},
  { 131, -1, -1, sizeof(::CEcad)},
  { 140, -1, -1, sizeof(::root)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CLayerRef_default_instance_._instance,
  &::_CColor_default_instance_._instance,
  &::_CEntryColor_default_instance_._instance,
  &::_CDictionaryColor_default_instance_._instance,
  &::_CContent_default_instance_._instance,
  &::_CProperty_default_instance_._instance,
  &::_CGeneral_default_instance_._instance,
  &::_CSpec_default_instance_._instance,
  &::_CCadHeader_default_instance_._instance,
  &::_CLayer_default_instance_._instance,
  &::_CSpecRef_default_instance_._instance,
  &::_CStackupLayer_default_instance_._instance,
  &::_CStackupGroup_default_instance_._instance,
  &::_CStackup_default_instance_._instance,
  &::_CCadData_default_instance_._instance,
  &::_CEcad_default_instance_._instance,
  &::_root_default_instance_._instance,
};

const char descriptor_table_protodef_test_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ntest.proto\"\031\n\tCLayerRef\022\014\n\004name\030\001 \001(\t\""
  ")\n\006CColor\022\t\n\001r\030\001 \001(\r\022\t\n\001g\030\002 \001(\r\022\t\n\001b\030\003 \001"
  "(\r\"1\n\013CEntryColor\022\n\n\002id\030\001 \001(\t\022\026\n\005Color\030\002"
  " \001(\0132\007.CColor\"5\n\020CDictionaryColor\022!\n\013ent"
  "ry_color\030\001 \003(\0132\014.CEntryColor\"T\n\010CContent"
  "\022\034\n\010LayerRef\030\001 \003(\0132\n.CLayerRef\022*\n\017Dictio"
  "naryColor\030\002 \001(\0132\021.CDictionaryColor\"6\n\tCP"
  "roperty\022\014\n\004text\030\001 \001(\t\022\014\n\004unit\030\002 \001(\t\022\r\n\005v"
  "alue\030\003 \001(\001\"H\n\010CGeneral\022\036\n\007General\030\001 \001(\0162"
  "\r.CGeneralType\022\034\n\010Property\030\002 \001(\0132\n.CProp"
  "erty\"1\n\005CSpec\022\014\n\004name\030\001 \001(\t\022\032\n\007General\030\002"
  " \003(\0132\t.CGeneral\":\n\nCCadHeader\022\026\n\005units\030\001"
  " \001(\0162\007.CUnits\022\024\n\004Spec\030\002 \003(\0132\006.CSpec\"M\n\006C"
  "Layer\022\014\n\004name\030\001 \001(\t\022\020\n\010polarity\030\002 \001(\t\022\014\n"
  "\004side\030\003 \001(\t\022\025\n\rlayerFunction\030\004 \001(\t\"\026\n\010CS"
  "pecRef\022\n\n\002id\030\001 \001(\t\"w\n\rCStackupLayer\022\017\n\007t"
  "oMinus\030\001 \001(\001\022\016\n\006toPlus\030\002 \001(\001\022\020\n\010sequence"
  "\030\003 \001(\005\022\027\n\017layerOrGroupRef\030\004 \001(\t\022\032\n\007SpecR"
  "ef\030\005 \001(\0132\t.CSpecRef\"~\n\rCStackupGroup\022\014\n\004"
  "name\030\001 \001(\t\022\017\n\007toMinus\030\002 \001(\001\022\016\n\006toPlus\030\003 "
  "\001(\001\022\027\n\017overallTickness\030\004 \001(\001\022%\n\rstackup_"
  "layer\030\005 \003(\0132\016.CStackupLayer\"\217\001\n\010CStackup"
  "\022\014\n\004name\030\001 \001(\t\022\025\n\rwhereMeasured\030\002 \001(\t\022\017\n"
  "\007toMinus\030\003 \001(\001\022\016\n\006toPlus\030\004 \001(\001\022\027\n\017overal"
  "lTickness\030\005 \001(\001\022$\n\014StackupGroup\030\006 \001(\0132\016."
  "CStackupGroup\">\n\010CCadData\022\026\n\005Layer\030\001 \003(\013"
  "2\007.CLayer\022\032\n\007Stackup\030\002 \001(\0132\t.CStackup\"Q\n"
  "\005CEcad\022\014\n\004name\030\001 \001(\t\022\036\n\tCadHeader\030\002 \001(\0132"
  "\013.CCadHeader\022\032\n\007CadData\030\003 \001(\0132\t.CCadData"
  "\"F\n\004root\022\014\n\004name\030\001 \001(\t\022\032\n\007Content\030\002 \001(\0132"
  "\t.CContent\022\024\n\004Ecad\030\003 \001(\0132\006.CEcad*/\n\014CGen"
  "eralType\022\014\n\010MATERIAL\020\000\022\021\n\rCONDUCITIVITY\020"
  "\001*\024\n\006CUnits\022\n\n\006MICRON\020\000b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_test_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_test_2eproto = {
    false, false, 1311, descriptor_table_protodef_test_2eproto,
    "test.proto",
    &descriptor_table_test_2eproto_once, nullptr, 0, 17,
    schemas, file_default_instances, TableStruct_test_2eproto::offsets,
    file_level_metadata_test_2eproto, file_level_enum_descriptors_test_2eproto,
    file_level_service_descriptors_test_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_test_2eproto_getter() {
  return &descriptor_table_test_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_test_2eproto(&descriptor_table_test_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CGeneralType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_test_2eproto);
  return file_level_enum_descriptors_test_2eproto[0];
}
bool CGeneralType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CUnits_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_test_2eproto);
  return file_level_enum_descriptors_test_2eproto[1];
}
bool CUnits_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CLayerRef::_Internal {
 public:
};

CLayerRef::CLayerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CLayerRef)
}
CLayerRef::CLayerRef(const CLayerRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CLayerRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CLayerRef)
}

inline void CLayerRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CLayerRef::~CLayerRef() {
  // @@protoc_insertion_point(destructor:CLayerRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CLayerRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CLayerRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CLayerRef::Clear() {
// @@protoc_insertion_point(message_clear_start:CLayerRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLayerRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CLayerRef.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLayerRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CLayerRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CLayerRef.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CLayerRef)
  return target;
}

size_t CLayerRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CLayerRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLayerRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CLayerRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLayerRef::GetClassData() const { return &_class_data_; }


void CLayerRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CLayerRef*>(&to_msg);
  auto& from = static_cast<const CLayerRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CLayerRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLayerRef::CopyFrom(const CLayerRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CLayerRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLayerRef::IsInitialized() const {
  return true;
}

void CLayerRef::InternalSwap(CLayerRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CLayerRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[0]);
}

// ===================================================================

class CColor::_Internal {
 public:
};

CColor::CColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CColor)
}
CColor::CColor(const CColor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CColor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){}
    , decltype(_impl_.g_){}
    , decltype(_impl_.b_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.r_, &from._impl_.r_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.b_) -
    reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.b_));
  // @@protoc_insertion_point(copy_constructor:CColor)
}

inline void CColor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){0u}
    , decltype(_impl_.g_){0u}
    , decltype(_impl_.b_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CColor::~CColor() {
  // @@protoc_insertion_point(destructor:CColor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CColor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CColor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CColor::Clear() {
// @@protoc_insertion_point(message_clear_start:CColor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.r_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.b_) -
      reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.b_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CColor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 r = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 g = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.g_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 b = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CColor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CColor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 r = 1;
  if (this->_internal_r() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_r(), target);
  }

  // uint32 g = 2;
  if (this->_internal_g() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_g(), target);
  }

  // uint32 b = 3;
  if (this->_internal_b() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CColor)
  return target;
}

size_t CColor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CColor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 r = 1;
  if (this->_internal_r() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_r());
  }

  // uint32 g = 2;
  if (this->_internal_g() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_g());
  }

  // uint32 b = 3;
  if (this->_internal_b() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CColor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CColor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CColor::GetClassData() const { return &_class_data_; }


void CColor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CColor*>(&to_msg);
  auto& from = static_cast<const CColor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CColor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_r() != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  if (from._internal_g() != 0) {
    _this->_internal_set_g(from._internal_g());
  }
  if (from._internal_b() != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CColor::CopyFrom(const CColor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CColor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CColor::IsInitialized() const {
  return true;
}

void CColor::InternalSwap(CColor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CColor, _impl_.b_)
      + sizeof(CColor::_impl_.b_)
      - PROTOBUF_FIELD_OFFSET(CColor, _impl_.r_)>(
          reinterpret_cast<char*>(&_impl_.r_),
          reinterpret_cast<char*>(&other->_impl_.r_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CColor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[1]);
}

// ===================================================================

class CEntryColor::_Internal {
 public:
  static const ::CColor& color(const CEntryColor* msg);
};

const ::CColor&
CEntryColor::_Internal::color(const CEntryColor* msg) {
  return *msg->_impl_.color_;
}
CEntryColor::CEntryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CEntryColor)
}
CEntryColor::CEntryColor(const CEntryColor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CEntryColor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.color_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::CColor(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:CEntryColor)
}

inline void CEntryColor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.color_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CEntryColor::~CEntryColor() {
  // @@protoc_insertion_point(destructor:CEntryColor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CEntryColor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.color_;
}

void CEntryColor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CEntryColor::Clear() {
// @@protoc_insertion_point(message_clear_start:CEntryColor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CEntryColor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CEntryColor.id"));
        } else
          goto handle_unusual;
        continue;
      // .CColor Color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CEntryColor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CEntryColor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CEntryColor.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // .CColor Color = 2;
  if (this->_internal_has_color()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CEntryColor)
  return target;
}

size_t CEntryColor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CEntryColor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // .CColor Color = 2;
  if (this->_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CEntryColor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CEntryColor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CEntryColor::GetClassData() const { return &_class_data_; }


void CEntryColor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CEntryColor*>(&to_msg);
  auto& from = static_cast<const CEntryColor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CEntryColor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::CColor::MergeFrom(
        from._internal_color());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CEntryColor::CopyFrom(const CEntryColor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CEntryColor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CEntryColor::IsInitialized() const {
  return true;
}

void CEntryColor::InternalSwap(CEntryColor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  swap(_impl_.color_, other->_impl_.color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CEntryColor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[2]);
}

// ===================================================================

class CDictionaryColor::_Internal {
 public:
};

CDictionaryColor::CDictionaryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDictionaryColor)
}
CDictionaryColor::CDictionaryColor(const CDictionaryColor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDictionaryColor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_color_){from._impl_.entry_color_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDictionaryColor)
}

inline void CDictionaryColor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_color_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CDictionaryColor::~CDictionaryColor() {
  // @@protoc_insertion_point(destructor:CDictionaryColor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDictionaryColor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entry_color_.~RepeatedPtrField();
}

void CDictionaryColor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDictionaryColor::Clear() {
// @@protoc_insertion_point(message_clear_start:CDictionaryColor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entry_color_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDictionaryColor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CEntryColor entry_color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry_color(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDictionaryColor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDictionaryColor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CEntryColor entry_color = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_color_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry_color(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDictionaryColor)
  return target;
}

size_t CDictionaryColor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDictionaryColor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CEntryColor entry_color = 1;
  total_size += 1UL * this->_internal_entry_color_size();
  for (const auto& msg : this->_impl_.entry_color_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDictionaryColor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDictionaryColor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDictionaryColor::GetClassData() const { return &_class_data_; }


void CDictionaryColor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDictionaryColor*>(&to_msg);
  auto& from = static_cast<const CDictionaryColor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDictionaryColor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entry_color_.MergeFrom(from._impl_.entry_color_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDictionaryColor::CopyFrom(const CDictionaryColor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDictionaryColor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDictionaryColor::IsInitialized() const {
  return true;
}

void CDictionaryColor::InternalSwap(CDictionaryColor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entry_color_.InternalSwap(&other->_impl_.entry_color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDictionaryColor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[3]);
}

// ===================================================================

class CContent::_Internal {
 public:
  static const ::CDictionaryColor& dictionarycolor(const CContent* msg);
};

const ::CDictionaryColor&
CContent::_Internal::dictionarycolor(const CContent* msg) {
  return *msg->_impl_.dictionarycolor_;
}
CContent::CContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CContent)
}
CContent::CContent(const CContent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CContent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layerref_){from._impl_.layerref_}
    , decltype(_impl_.dictionarycolor_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dictionarycolor()) {
    _this->_impl_.dictionarycolor_ = new ::CDictionaryColor(*from._impl_.dictionarycolor_);
  }
  // @@protoc_insertion_point(copy_constructor:CContent)
}

inline void CContent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layerref_){arena}
    , decltype(_impl_.dictionarycolor_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CContent::~CContent() {
  // @@protoc_insertion_point(destructor:CContent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CContent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layerref_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.dictionarycolor_;
}

void CContent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CContent::Clear() {
// @@protoc_insertion_point(message_clear_start:CContent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layerref_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.dictionarycolor_ != nullptr) {
    delete _impl_.dictionarycolor_;
  }
  _impl_.dictionarycolor_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CLayerRef LayerRef = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layerref(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CDictionaryColor DictionaryColor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dictionarycolor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CLayerRef LayerRef = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_layerref_size()); i < n; i++) {
    const auto& repfield = this->_internal_layerref(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .CDictionaryColor DictionaryColor = 2;
  if (this->_internal_has_dictionarycolor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dictionarycolor(this),
        _Internal::dictionarycolor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContent)
  return target;
}

size_t CContent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CLayerRef LayerRef = 1;
  total_size += 1UL * this->_internal_layerref_size();
  for (const auto& msg : this->_impl_.layerref_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CDictionaryColor DictionaryColor = 2;
  if (this->_internal_has_dictionarycolor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dictionarycolor_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CContent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContent::GetClassData() const { return &_class_data_; }


void CContent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CContent*>(&to_msg);
  auto& from = static_cast<const CContent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CContent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layerref_.MergeFrom(from._impl_.layerref_);
  if (from._internal_has_dictionarycolor()) {
    _this->_internal_mutable_dictionarycolor()->::CDictionaryColor::MergeFrom(
        from._internal_dictionarycolor());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContent::CopyFrom(const CContent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContent::IsInitialized() const {
  return true;
}

void CContent::InternalSwap(CContent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.layerref_.InternalSwap(&other->_impl_.layerref_);
  swap(_impl_.dictionarycolor_, other->_impl_.dictionarycolor_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[4]);
}

// ===================================================================

class CProperty::_Internal {
 public:
};

CProperty::CProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProperty)
}
CProperty::CProperty(const CProperty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CProperty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unit().empty()) {
    _this->_impl_.unit_.Set(from._internal_unit(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:CProperty)
}

inline void CProperty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.value_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CProperty::~CProperty() {
  // @@protoc_insertion_point(destructor:CProperty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProperty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
  _impl_.unit_.Destroy();
}

void CProperty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProperty::Clear() {
// @@protoc_insertion_point(message_clear_start:CProperty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  _impl_.unit_.ClearToEmpty();
  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CProperty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CProperty.text"));
        } else
          goto handle_unusual;
        continue;
      // string unit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_unit();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CProperty.unit"));
        } else
          goto handle_unusual;
        continue;
      // double value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProperty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProperty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CProperty.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unit().data(), static_cast<int>(this->_internal_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CProperty.unit");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_unit(), target);
  }

  // double value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProperty)
  return target;
}

size_t CProperty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProperty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // string unit = 2;
  if (!this->_internal_unit().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit());
  }

  // double value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CProperty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CProperty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CProperty::GetClassData() const { return &_class_data_; }


void CProperty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CProperty*>(&to_msg);
  auto& from = static_cast<const CProperty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CProperty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (!from._internal_unit().empty()) {
    _this->_internal_set_unit(from._internal_unit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CProperty::CopyFrom(const CProperty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProperty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProperty::IsInitialized() const {
  return true;
}

void CProperty::InternalSwap(CProperty* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unit_, lhs_arena,
      &other->_impl_.unit_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CProperty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[5]);
}

// ===================================================================

class CGeneral::_Internal {
 public:
  static const ::CProperty& property(const CGeneral* msg);
};

const ::CProperty&
CGeneral::_Internal::property(const CGeneral* msg) {
  return *msg->_impl_.property_;
}
CGeneral::CGeneral(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGeneral)
}
CGeneral::CGeneral(const CGeneral& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGeneral* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.property_){nullptr}
    , decltype(_impl_.general_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_property()) {
    _this->_impl_.property_ = new ::CProperty(*from._impl_.property_);
  }
  _this->_impl_.general_ = from._impl_.general_;
  // @@protoc_insertion_point(copy_constructor:CGeneral)
}

inline void CGeneral::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.property_){nullptr}
    , decltype(_impl_.general_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGeneral::~CGeneral() {
  // @@protoc_insertion_point(destructor:CGeneral)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGeneral::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.property_;
}

void CGeneral::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGeneral::Clear() {
// @@protoc_insertion_point(message_clear_start:CGeneral)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.property_ != nullptr) {
    delete _impl_.property_;
  }
  _impl_.property_ = nullptr;
  _impl_.general_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGeneral::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CGeneralType General = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_general(static_cast<::CGeneralType>(val));
        } else
          goto handle_unusual;
        continue;
      // .CProperty Property = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_property(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGeneral::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGeneral)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CGeneralType General = 1;
  if (this->_internal_general() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_general(), target);
  }

  // .CProperty Property = 2;
  if (this->_internal_has_property()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::property(this),
        _Internal::property(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGeneral)
  return target;
}

size_t CGeneral::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGeneral)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CProperty Property = 2;
  if (this->_internal_has_property()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.property_);
  }

  // .CGeneralType General = 1;
  if (this->_internal_general() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_general());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGeneral::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGeneral::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGeneral::GetClassData() const { return &_class_data_; }


void CGeneral::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGeneral*>(&to_msg);
  auto& from = static_cast<const CGeneral&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGeneral)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_property()) {
    _this->_internal_mutable_property()->::CProperty::MergeFrom(
        from._internal_property());
  }
  if (from._internal_general() != 0) {
    _this->_internal_set_general(from._internal_general());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGeneral::CopyFrom(const CGeneral& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGeneral)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGeneral::IsInitialized() const {
  return true;
}

void CGeneral::InternalSwap(CGeneral* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGeneral, _impl_.general_)
      + sizeof(CGeneral::_impl_.general_)
      - PROTOBUF_FIELD_OFFSET(CGeneral, _impl_.property_)>(
          reinterpret_cast<char*>(&_impl_.property_),
          reinterpret_cast<char*>(&other->_impl_.property_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGeneral::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[6]);
}

// ===================================================================

class CSpec::_Internal {
 public:
};

CSpec::CSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSpec)
}
CSpec::CSpec(const CSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.general_){from._impl_.general_}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSpec)
}

inline void CSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.general_){arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSpec::~CSpec() {
  // @@protoc_insertion_point(destructor:CSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.general_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:CSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.general_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CSpec.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .CGeneral General = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_general(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CSpec.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .CGeneral General = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_general_size()); i < n; i++) {
    const auto& repfield = this->_internal_general(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSpec)
  return target;
}

size_t CSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGeneral General = 2;
  total_size += 1UL * this->_internal_general_size();
  for (const auto& msg : this->_impl_.general_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSpec::GetClassData() const { return &_class_data_; }


void CSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSpec*>(&to_msg);
  auto& from = static_cast<const CSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.general_.MergeFrom(from._impl_.general_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSpec::CopyFrom(const CSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSpec::IsInitialized() const {
  return true;
}

void CSpec::InternalSwap(CSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.general_.InternalSwap(&other->_impl_.general_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[7]);
}

// ===================================================================

class CCadHeader::_Internal {
 public:
};

CCadHeader::CCadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCadHeader)
}
CCadHeader::CCadHeader(const CCadHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCadHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.spec_){from._impl_.spec_}
    , decltype(_impl_.units_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.units_ = from._impl_.units_;
  // @@protoc_insertion_point(copy_constructor:CCadHeader)
}

inline void CCadHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.spec_){arena}
    , decltype(_impl_.units_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CCadHeader::~CCadHeader() {
  // @@protoc_insertion_point(destructor:CCadHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCadHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.spec_.~RepeatedPtrField();
}

void CCadHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCadHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CCadHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.spec_.Clear();
  _impl_.units_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCadHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CUnits units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_units(static_cast<::CUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .CSpec Spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spec(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCadHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCadHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CUnits units = 1;
  if (this->_internal_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // repeated .CSpec Spec = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spec_size()); i < n; i++) {
    const auto& repfield = this->_internal_spec(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCadHeader)
  return target;
}

size_t CCadHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCadHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSpec Spec = 2;
  total_size += 1UL * this->_internal_spec_size();
  for (const auto& msg : this->_impl_.spec_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CUnits units = 1;
  if (this->_internal_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_units());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCadHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCadHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCadHeader::GetClassData() const { return &_class_data_; }


void CCadHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCadHeader*>(&to_msg);
  auto& from = static_cast<const CCadHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCadHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.spec_.MergeFrom(from._impl_.spec_);
  if (from._internal_units() != 0) {
    _this->_internal_set_units(from._internal_units());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCadHeader::CopyFrom(const CCadHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCadHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCadHeader::IsInitialized() const {
  return true;
}

void CCadHeader::InternalSwap(CCadHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.spec_.InternalSwap(&other->_impl_.spec_);
  swap(_impl_.units_, other->_impl_.units_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCadHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[8]);
}

// ===================================================================

class CLayer::_Internal {
 public:
};

CLayer::CLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CLayer)
}
CLayer::CLayer(const CLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.polarity_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.layerfunction_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.polarity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.polarity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_polarity().empty()) {
    _this->_impl_.polarity_.Set(from._internal_polarity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.side_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_side().empty()) {
    _this->_impl_.side_.Set(from._internal_side(), 
      _this->GetArenaForAllocation());
  }
  _impl_.layerfunction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layerfunction_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_layerfunction().empty()) {
    _this->_impl_.layerfunction_.Set(from._internal_layerfunction(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CLayer)
}

inline void CLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.polarity_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.layerfunction_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.polarity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.polarity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.side_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.layerfunction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layerfunction_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CLayer::~CLayer() {
  // @@protoc_insertion_point(destructor:CLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.polarity_.Destroy();
  _impl_.side_.Destroy();
  _impl_.layerfunction_.Destroy();
}

void CLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.polarity_.ClearToEmpty();
  _impl_.side_.ClearToEmpty();
  _impl_.layerfunction_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CLayer.name"));
        } else
          goto handle_unusual;
        continue;
      // string polarity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_polarity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CLayer.polarity"));
        } else
          goto handle_unusual;
        continue;
      // string side = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CLayer.side"));
        } else
          goto handle_unusual;
        continue;
      // string layerFunction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_layerfunction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CLayer.layerFunction"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string polarity = 2;
  if (!this->_internal_polarity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_polarity().data(), static_cast<int>(this->_internal_polarity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CLayer.polarity");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_polarity(), target);
  }

  // string side = 3;
  if (!this->_internal_side().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_side().data(), static_cast<int>(this->_internal_side().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CLayer.side");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_side(), target);
  }

  // string layerFunction = 4;
  if (!this->_internal_layerfunction().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_layerfunction().data(), static_cast<int>(this->_internal_layerfunction().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CLayer.layerFunction");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_layerfunction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CLayer)
  return target;
}

size_t CLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string polarity = 2;
  if (!this->_internal_polarity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_polarity());
  }

  // string side = 3;
  if (!this->_internal_side().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_side());
  }

  // string layerFunction = 4;
  if (!this->_internal_layerfunction().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layerfunction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLayer::GetClassData() const { return &_class_data_; }


void CLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CLayer*>(&to_msg);
  auto& from = static_cast<const CLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_polarity().empty()) {
    _this->_internal_set_polarity(from._internal_polarity());
  }
  if (!from._internal_side().empty()) {
    _this->_internal_set_side(from._internal_side());
  }
  if (!from._internal_layerfunction().empty()) {
    _this->_internal_set_layerfunction(from._internal_layerfunction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLayer::CopyFrom(const CLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLayer::IsInitialized() const {
  return true;
}

void CLayer::InternalSwap(CLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.polarity_, lhs_arena,
      &other->_impl_.polarity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.side_, lhs_arena,
      &other->_impl_.side_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.layerfunction_, lhs_arena,
      &other->_impl_.layerfunction_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[9]);
}

// ===================================================================

class CSpecRef::_Internal {
 public:
};

CSpecRef::CSpecRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSpecRef)
}
CSpecRef::CSpecRef(const CSpecRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSpecRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSpecRef)
}

inline void CSpecRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSpecRef::~CSpecRef() {
  // @@protoc_insertion_point(destructor:CSpecRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSpecRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void CSpecRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSpecRef::Clear() {
// @@protoc_insertion_point(message_clear_start:CSpecRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSpecRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CSpecRef.id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSpecRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSpecRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CSpecRef.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSpecRef)
  return target;
}

size_t CSpecRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSpecRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSpecRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSpecRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSpecRef::GetClassData() const { return &_class_data_; }


void CSpecRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSpecRef*>(&to_msg);
  auto& from = static_cast<const CSpecRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSpecRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSpecRef::CopyFrom(const CSpecRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSpecRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSpecRef::IsInitialized() const {
  return true;
}

void CSpecRef::InternalSwap(CSpecRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSpecRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[10]);
}

// ===================================================================

class CStackupLayer::_Internal {
 public:
  static const ::CSpecRef& specref(const CStackupLayer* msg);
};

const ::CSpecRef&
CStackupLayer::_Internal::specref(const CStackupLayer* msg) {
  return *msg->_impl_.specref_;
}
CStackupLayer::CStackupLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CStackupLayer)
}
CStackupLayer::CStackupLayer(const CStackupLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CStackupLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layerorgroupref_){}
    , decltype(_impl_.specref_){nullptr}
    , decltype(_impl_.tominus_){}
    , decltype(_impl_.toplus_){}
    , decltype(_impl_.sequence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.layerorgroupref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layerorgroupref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_layerorgroupref().empty()) {
    _this->_impl_.layerorgroupref_.Set(from._internal_layerorgroupref(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_specref()) {
    _this->_impl_.specref_ = new ::CSpecRef(*from._impl_.specref_);
  }
  ::memcpy(&_impl_.tominus_, &from._impl_.tominus_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sequence_) -
    reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.sequence_));
  // @@protoc_insertion_point(copy_constructor:CStackupLayer)
}

inline void CStackupLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layerorgroupref_){}
    , decltype(_impl_.specref_){nullptr}
    , decltype(_impl_.tominus_){0}
    , decltype(_impl_.toplus_){0}
    , decltype(_impl_.sequence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.layerorgroupref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layerorgroupref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CStackupLayer::~CStackupLayer() {
  // @@protoc_insertion_point(destructor:CStackupLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CStackupLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layerorgroupref_.Destroy();
  if (this != internal_default_instance()) delete _impl_.specref_;
}

void CStackupLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CStackupLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CStackupLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layerorgroupref_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.specref_ != nullptr) {
    delete _impl_.specref_;
  }
  _impl_.specref_ = nullptr;
  ::memset(&_impl_.tominus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sequence_) -
      reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.sequence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStackupLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double toMinus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.tominus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double toPlus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.toplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 sequence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string layerOrGroupRef = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_layerorgroupref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CStackupLayer.layerOrGroupRef"));
        } else
          goto handle_unusual;
        continue;
      // .CSpecRef SpecRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_specref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStackupLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStackupLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double toMinus = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_tominus(), target);
  }

  // double toPlus = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_toplus(), target);
  }

  // int32 sequence = 3;
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sequence(), target);
  }

  // string layerOrGroupRef = 4;
  if (!this->_internal_layerorgroupref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_layerorgroupref().data(), static_cast<int>(this->_internal_layerorgroupref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CStackupLayer.layerOrGroupRef");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_layerorgroupref(), target);
  }

  // .CSpecRef SpecRef = 5;
  if (this->_internal_has_specref()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::specref(this),
        _Internal::specref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStackupLayer)
  return target;
}

size_t CStackupLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStackupLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string layerOrGroupRef = 4;
  if (!this->_internal_layerorgroupref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layerorgroupref());
  }

  // .CSpecRef SpecRef = 5;
  if (this->_internal_has_specref()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.specref_);
  }

  // double toMinus = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    total_size += 1 + 8;
  }

  // double toPlus = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    total_size += 1 + 8;
  }

  // int32 sequence = 3;
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStackupLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CStackupLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStackupLayer::GetClassData() const { return &_class_data_; }


void CStackupLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CStackupLayer*>(&to_msg);
  auto& from = static_cast<const CStackupLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CStackupLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_layerorgroupref().empty()) {
    _this->_internal_set_layerorgroupref(from._internal_layerorgroupref());
  }
  if (from._internal_has_specref()) {
    _this->_internal_mutable_specref()->::CSpecRef::MergeFrom(
        from._internal_specref());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = from._internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    _this->_internal_set_tominus(from._internal_tominus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = from._internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    _this->_internal_set_toplus(from._internal_toplus());
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStackupLayer::CopyFrom(const CStackupLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStackupLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStackupLayer::IsInitialized() const {
  return true;
}

void CStackupLayer::InternalSwap(CStackupLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.layerorgroupref_, lhs_arena,
      &other->_impl_.layerorgroupref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStackupLayer, _impl_.sequence_)
      + sizeof(CStackupLayer::_impl_.sequence_)
      - PROTOBUF_FIELD_OFFSET(CStackupLayer, _impl_.specref_)>(
          reinterpret_cast<char*>(&_impl_.specref_),
          reinterpret_cast<char*>(&other->_impl_.specref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStackupLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[11]);
}

// ===================================================================

class CStackupGroup::_Internal {
 public:
};

CStackupGroup::CStackupGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CStackupGroup)
}
CStackupGroup::CStackupGroup(const CStackupGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CStackupGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stackup_layer_){from._impl_.stackup_layer_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.tominus_){}
    , decltype(_impl_.toplus_){}
    , decltype(_impl_.overalltickness_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tominus_, &from._impl_.tominus_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overalltickness_) -
    reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.overalltickness_));
  // @@protoc_insertion_point(copy_constructor:CStackupGroup)
}

inline void CStackupGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stackup_layer_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.tominus_){0}
    , decltype(_impl_.toplus_){0}
    , decltype(_impl_.overalltickness_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CStackupGroup::~CStackupGroup() {
  // @@protoc_insertion_point(destructor:CStackupGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CStackupGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stackup_layer_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CStackupGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CStackupGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:CStackupGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stackup_layer_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.tominus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.overalltickness_) -
      reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.overalltickness_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStackupGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CStackupGroup.name"));
        } else
          goto handle_unusual;
        continue;
      // double toMinus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.tominus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double toPlus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.toplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double overallTickness = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.overalltickness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .CStackupLayer stackup_layer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stackup_layer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStackupGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStackupGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CStackupGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // double toMinus = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_tominus(), target);
  }

  // double toPlus = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_toplus(), target);
  }

  // double overallTickness = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = this->_internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_overalltickness(), target);
  }

  // repeated .CStackupLayer stackup_layer = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stackup_layer_size()); i < n; i++) {
    const auto& repfield = this->_internal_stackup_layer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStackupGroup)
  return target;
}

size_t CStackupGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStackupGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStackupLayer stackup_layer = 5;
  total_size += 1UL * this->_internal_stackup_layer_size();
  for (const auto& msg : this->_impl_.stackup_layer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // double toMinus = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    total_size += 1 + 8;
  }

  // double toPlus = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    total_size += 1 + 8;
  }

  // double overallTickness = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = this->_internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStackupGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CStackupGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStackupGroup::GetClassData() const { return &_class_data_; }


void CStackupGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CStackupGroup*>(&to_msg);
  auto& from = static_cast<const CStackupGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CStackupGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stackup_layer_.MergeFrom(from._impl_.stackup_layer_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = from._internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    _this->_internal_set_tominus(from._internal_tominus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = from._internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    _this->_internal_set_toplus(from._internal_toplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = from._internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    _this->_internal_set_overalltickness(from._internal_overalltickness());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStackupGroup::CopyFrom(const CStackupGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStackupGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStackupGroup::IsInitialized() const {
  return true;
}

void CStackupGroup::InternalSwap(CStackupGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stackup_layer_.InternalSwap(&other->_impl_.stackup_layer_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStackupGroup, _impl_.overalltickness_)
      + sizeof(CStackupGroup::_impl_.overalltickness_)
      - PROTOBUF_FIELD_OFFSET(CStackupGroup, _impl_.tominus_)>(
          reinterpret_cast<char*>(&_impl_.tominus_),
          reinterpret_cast<char*>(&other->_impl_.tominus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStackupGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[12]);
}

// ===================================================================

class CStackup::_Internal {
 public:
  static const ::CStackupGroup& stackupgroup(const CStackup* msg);
};

const ::CStackupGroup&
CStackup::_Internal::stackupgroup(const CStackup* msg) {
  return *msg->_impl_.stackupgroup_;
}
CStackup::CStackup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CStackup)
}
CStackup::CStackup(const CStackup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CStackup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.wheremeasured_){}
    , decltype(_impl_.stackupgroup_){nullptr}
    , decltype(_impl_.tominus_){}
    , decltype(_impl_.toplus_){}
    , decltype(_impl_.overalltickness_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.wheremeasured_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wheremeasured_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wheremeasured().empty()) {
    _this->_impl_.wheremeasured_.Set(from._internal_wheremeasured(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_stackupgroup()) {
    _this->_impl_.stackupgroup_ = new ::CStackupGroup(*from._impl_.stackupgroup_);
  }
  ::memcpy(&_impl_.tominus_, &from._impl_.tominus_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overalltickness_) -
    reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.overalltickness_));
  // @@protoc_insertion_point(copy_constructor:CStackup)
}

inline void CStackup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.wheremeasured_){}
    , decltype(_impl_.stackupgroup_){nullptr}
    , decltype(_impl_.tominus_){0}
    , decltype(_impl_.toplus_){0}
    , decltype(_impl_.overalltickness_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wheremeasured_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wheremeasured_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CStackup::~CStackup() {
  // @@protoc_insertion_point(destructor:CStackup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CStackup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.wheremeasured_.Destroy();
  if (this != internal_default_instance()) delete _impl_.stackupgroup_;
}

void CStackup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CStackup::Clear() {
// @@protoc_insertion_point(message_clear_start:CStackup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.wheremeasured_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.stackupgroup_ != nullptr) {
    delete _impl_.stackupgroup_;
  }
  _impl_.stackupgroup_ = nullptr;
  ::memset(&_impl_.tominus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.overalltickness_) -
      reinterpret_cast<char*>(&_impl_.tominus_)) + sizeof(_impl_.overalltickness_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStackup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CStackup.name"));
        } else
          goto handle_unusual;
        continue;
      // string whereMeasured = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_wheremeasured();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CStackup.whereMeasured"));
        } else
          goto handle_unusual;
        continue;
      // double toMinus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.tominus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double toPlus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.toplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double overallTickness = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.overalltickness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .CStackupGroup StackupGroup = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_stackupgroup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStackup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStackup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CStackup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string whereMeasured = 2;
  if (!this->_internal_wheremeasured().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_wheremeasured().data(), static_cast<int>(this->_internal_wheremeasured().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CStackup.whereMeasured");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_wheremeasured(), target);
  }

  // double toMinus = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_tominus(), target);
  }

  // double toPlus = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_toplus(), target);
  }

  // double overallTickness = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = this->_internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_overalltickness(), target);
  }

  // .CStackupGroup StackupGroup = 6;
  if (this->_internal_has_stackupgroup()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::stackupgroup(this),
        _Internal::stackupgroup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStackup)
  return target;
}

size_t CStackup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStackup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string whereMeasured = 2;
  if (!this->_internal_wheremeasured().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_wheremeasured());
  }

  // .CStackupGroup StackupGroup = 6;
  if (this->_internal_has_stackupgroup()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stackupgroup_);
  }

  // double toMinus = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = this->_internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    total_size += 1 + 8;
  }

  // double toPlus = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = this->_internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    total_size += 1 + 8;
  }

  // double overallTickness = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = this->_internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStackup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CStackup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStackup::GetClassData() const { return &_class_data_; }


void CStackup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CStackup*>(&to_msg);
  auto& from = static_cast<const CStackup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CStackup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_wheremeasured().empty()) {
    _this->_internal_set_wheremeasured(from._internal_wheremeasured());
  }
  if (from._internal_has_stackupgroup()) {
    _this->_internal_mutable_stackupgroup()->::CStackupGroup::MergeFrom(
        from._internal_stackupgroup());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tominus = from._internal_tominus();
  uint64_t raw_tominus;
  memcpy(&raw_tominus, &tmp_tominus, sizeof(tmp_tominus));
  if (raw_tominus != 0) {
    _this->_internal_set_tominus(from._internal_tominus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_toplus = from._internal_toplus();
  uint64_t raw_toplus;
  memcpy(&raw_toplus, &tmp_toplus, sizeof(tmp_toplus));
  if (raw_toplus != 0) {
    _this->_internal_set_toplus(from._internal_toplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_overalltickness = from._internal_overalltickness();
  uint64_t raw_overalltickness;
  memcpy(&raw_overalltickness, &tmp_overalltickness, sizeof(tmp_overalltickness));
  if (raw_overalltickness != 0) {
    _this->_internal_set_overalltickness(from._internal_overalltickness());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStackup::CopyFrom(const CStackup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStackup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStackup::IsInitialized() const {
  return true;
}

void CStackup::InternalSwap(CStackup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wheremeasured_, lhs_arena,
      &other->_impl_.wheremeasured_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStackup, _impl_.overalltickness_)
      + sizeof(CStackup::_impl_.overalltickness_)
      - PROTOBUF_FIELD_OFFSET(CStackup, _impl_.stackupgroup_)>(
          reinterpret_cast<char*>(&_impl_.stackupgroup_),
          reinterpret_cast<char*>(&other->_impl_.stackupgroup_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStackup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[13]);
}

// ===================================================================

class CCadData::_Internal {
 public:
  static const ::CStackup& stackup(const CCadData* msg);
};

const ::CStackup&
CCadData::_Internal::stackup(const CCadData* msg) {
  return *msg->_impl_.stackup_;
}
CCadData::CCadData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCadData)
}
CCadData::CCadData(const CCadData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCadData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layer_){from._impl_.layer_}
    , decltype(_impl_.stackup_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stackup()) {
    _this->_impl_.stackup_ = new ::CStackup(*from._impl_.stackup_);
  }
  // @@protoc_insertion_point(copy_constructor:CCadData)
}

inline void CCadData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layer_){arena}
    , decltype(_impl_.stackup_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CCadData::~CCadData() {
  // @@protoc_insertion_point(destructor:CCadData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCadData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layer_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.stackup_;
}

void CCadData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCadData::Clear() {
// @@protoc_insertion_point(message_clear_start:CCadData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layer_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.stackup_ != nullptr) {
    delete _impl_.stackup_;
  }
  _impl_.stackup_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCadData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CLayer Layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CStackup Stackup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stackup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCadData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCadData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CLayer Layer = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_layer_size()); i < n; i++) {
    const auto& repfield = this->_internal_layer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .CStackup Stackup = 2;
  if (this->_internal_has_stackup()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stackup(this),
        _Internal::stackup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCadData)
  return target;
}

size_t CCadData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCadData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CLayer Layer = 1;
  total_size += 1UL * this->_internal_layer_size();
  for (const auto& msg : this->_impl_.layer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .CStackup Stackup = 2;
  if (this->_internal_has_stackup()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stackup_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCadData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCadData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCadData::GetClassData() const { return &_class_data_; }


void CCadData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCadData*>(&to_msg);
  auto& from = static_cast<const CCadData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCadData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layer_.MergeFrom(from._impl_.layer_);
  if (from._internal_has_stackup()) {
    _this->_internal_mutable_stackup()->::CStackup::MergeFrom(
        from._internal_stackup());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCadData::CopyFrom(const CCadData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCadData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCadData::IsInitialized() const {
  return true;
}

void CCadData::InternalSwap(CCadData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.layer_.InternalSwap(&other->_impl_.layer_);
  swap(_impl_.stackup_, other->_impl_.stackup_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCadData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[14]);
}

// ===================================================================

class CEcad::_Internal {
 public:
  static const ::CCadHeader& cadheader(const CEcad* msg);
  static const ::CCadData& caddata(const CEcad* msg);
};

const ::CCadHeader&
CEcad::_Internal::cadheader(const CEcad* msg) {
  return *msg->_impl_.cadheader_;
}
const ::CCadData&
CEcad::_Internal::caddata(const CEcad* msg) {
  return *msg->_impl_.caddata_;
}
CEcad::CEcad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CEcad)
}
CEcad::CEcad(const CEcad& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CEcad* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.cadheader_){nullptr}
    , decltype(_impl_.caddata_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cadheader()) {
    _this->_impl_.cadheader_ = new ::CCadHeader(*from._impl_.cadheader_);
  }
  if (from._internal_has_caddata()) {
    _this->_impl_.caddata_ = new ::CCadData(*from._impl_.caddata_);
  }
  // @@protoc_insertion_point(copy_constructor:CEcad)
}

inline void CEcad::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.cadheader_){nullptr}
    , decltype(_impl_.caddata_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CEcad::~CEcad() {
  // @@protoc_insertion_point(destructor:CEcad)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CEcad::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cadheader_;
  if (this != internal_default_instance()) delete _impl_.caddata_;
}

void CEcad::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CEcad::Clear() {
// @@protoc_insertion_point(message_clear_start:CEcad)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.cadheader_ != nullptr) {
    delete _impl_.cadheader_;
  }
  _impl_.cadheader_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.caddata_ != nullptr) {
    delete _impl_.caddata_;
  }
  _impl_.caddata_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CEcad::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CEcad.name"));
        } else
          goto handle_unusual;
        continue;
      // .CCadHeader CadHeader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cadheader(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CCadData CadData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_caddata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CEcad::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CEcad)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CEcad.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .CCadHeader CadHeader = 2;
  if (this->_internal_has_cadheader()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cadheader(this),
        _Internal::cadheader(this).GetCachedSize(), target, stream);
  }

  // .CCadData CadData = 3;
  if (this->_internal_has_caddata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::caddata(this),
        _Internal::caddata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CEcad)
  return target;
}

size_t CEcad::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CEcad)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .CCadHeader CadHeader = 2;
  if (this->_internal_has_cadheader()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cadheader_);
  }

  // .CCadData CadData = 3;
  if (this->_internal_has_caddata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.caddata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CEcad::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CEcad::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CEcad::GetClassData() const { return &_class_data_; }


void CEcad::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CEcad*>(&to_msg);
  auto& from = static_cast<const CEcad&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CEcad)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_cadheader()) {
    _this->_internal_mutable_cadheader()->::CCadHeader::MergeFrom(
        from._internal_cadheader());
  }
  if (from._internal_has_caddata()) {
    _this->_internal_mutable_caddata()->::CCadData::MergeFrom(
        from._internal_caddata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CEcad::CopyFrom(const CEcad& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CEcad)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CEcad::IsInitialized() const {
  return true;
}

void CEcad::InternalSwap(CEcad* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CEcad, _impl_.caddata_)
      + sizeof(CEcad::_impl_.caddata_)
      - PROTOBUF_FIELD_OFFSET(CEcad, _impl_.cadheader_)>(
          reinterpret_cast<char*>(&_impl_.cadheader_),
          reinterpret_cast<char*>(&other->_impl_.cadheader_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CEcad::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[15]);
}

// ===================================================================

class root::_Internal {
 public:
  static const ::CContent& content(const root* msg);
  static const ::CEcad& ecad(const root* msg);
};

const ::CContent&
root::_Internal::content(const root* msg) {
  return *msg->_impl_.content_;
}
const ::CEcad&
root::_Internal::ecad(const root* msg) {
  return *msg->_impl_.ecad_;
}
root::root(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:root)
}
root::root(const root& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  root* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.ecad_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_content()) {
    _this->_impl_.content_ = new ::CContent(*from._impl_.content_);
  }
  if (from._internal_has_ecad()) {
    _this->_impl_.ecad_ = new ::CEcad(*from._impl_.ecad_);
  }
  // @@protoc_insertion_point(copy_constructor:root)
}

inline void root::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){nullptr}
    , decltype(_impl_.ecad_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

root::~root() {
  // @@protoc_insertion_point(destructor:root)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void root::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.content_;
  if (this != internal_default_instance()) delete _impl_.ecad_;
}

void root::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void root::Clear() {
// @@protoc_insertion_point(message_clear_start:root)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ecad_ != nullptr) {
    delete _impl_.ecad_;
  }
  _impl_.ecad_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* root::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "root.name"));
        } else
          goto handle_unusual;
        continue;
      // .CContent Content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CEcad Ecad = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecad(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* root::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:root)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "root.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .CContent Content = 2;
  if (this->_internal_has_content()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  // .CEcad Ecad = 3;
  if (this->_internal_has_ecad()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ecad(this),
        _Internal::ecad(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:root)
  return target;
}

size_t root::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:root)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .CContent Content = 2;
  if (this->_internal_has_content()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.content_);
  }

  // .CEcad Ecad = 3;
  if (this->_internal_has_ecad()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ecad_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData root::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    root::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*root::GetClassData() const { return &_class_data_; }


void root::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<root*>(&to_msg);
  auto& from = static_cast<const root&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:root)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_content()) {
    _this->_internal_mutable_content()->::CContent::MergeFrom(
        from._internal_content());
  }
  if (from._internal_has_ecad()) {
    _this->_internal_mutable_ecad()->::CEcad::MergeFrom(
        from._internal_ecad());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void root::CopyFrom(const root& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:root)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool root::IsInitialized() const {
  return true;
}

void root::InternalSwap(root* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(root, _impl_.ecad_)
      + sizeof(root::_impl_.ecad_)
      - PROTOBUF_FIELD_OFFSET(root, _impl_.content_)>(
          reinterpret_cast<char*>(&_impl_.content_),
          reinterpret_cast<char*>(&other->_impl_.content_));
}

::PROTOBUF_NAMESPACE_ID::Metadata root::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_test_2eproto_getter, &descriptor_table_test_2eproto_once,
      file_level_metadata_test_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CLayerRef*
Arena::CreateMaybeMessage< ::CLayerRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CLayerRef >(arena);
}
template<> PROTOBUF_NOINLINE ::CColor*
Arena::CreateMaybeMessage< ::CColor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CColor >(arena);
}
template<> PROTOBUF_NOINLINE ::CEntryColor*
Arena::CreateMaybeMessage< ::CEntryColor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CEntryColor >(arena);
}
template<> PROTOBUF_NOINLINE ::CDictionaryColor*
Arena::CreateMaybeMessage< ::CDictionaryColor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDictionaryColor >(arena);
}
template<> PROTOBUF_NOINLINE ::CContent*
Arena::CreateMaybeMessage< ::CContent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContent >(arena);
}
template<> PROTOBUF_NOINLINE ::CProperty*
Arena::CreateMaybeMessage< ::CProperty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProperty >(arena);
}
template<> PROTOBUF_NOINLINE ::CGeneral*
Arena::CreateMaybeMessage< ::CGeneral >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGeneral >(arena);
}
template<> PROTOBUF_NOINLINE ::CSpec*
Arena::CreateMaybeMessage< ::CSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::CCadHeader*
Arena::CreateMaybeMessage< ::CCadHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCadHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CLayer*
Arena::CreateMaybeMessage< ::CLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CSpecRef*
Arena::CreateMaybeMessage< ::CSpecRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSpecRef >(arena);
}
template<> PROTOBUF_NOINLINE ::CStackupLayer*
Arena::CreateMaybeMessage< ::CStackupLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStackupLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CStackupGroup*
Arena::CreateMaybeMessage< ::CStackupGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStackupGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::CStackup*
Arena::CreateMaybeMessage< ::CStackup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStackup >(arena);
}
template<> PROTOBUF_NOINLINE ::CCadData*
Arena::CreateMaybeMessage< ::CCadData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCadData >(arena);
}
template<> PROTOBUF_NOINLINE ::CEcad*
Arena::CreateMaybeMessage< ::CEcad >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CEcad >(arena);
}
template<> PROTOBUF_NOINLINE ::root*
Arena::CreateMaybeMessage< ::root >(Arena* arena) {
  return Arena::CreateMessageInternal< ::root >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
