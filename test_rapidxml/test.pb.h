// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_test_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_test_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_test_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_test_2eproto;
class CCadData;
struct CCadDataDefaultTypeInternal;
extern CCadDataDefaultTypeInternal _CCadData_default_instance_;
class CCadHeader;
struct CCadHeaderDefaultTypeInternal;
extern CCadHeaderDefaultTypeInternal _CCadHeader_default_instance_;
class CColor;
struct CColorDefaultTypeInternal;
extern CColorDefaultTypeInternal _CColor_default_instance_;
class CContent;
struct CContentDefaultTypeInternal;
extern CContentDefaultTypeInternal _CContent_default_instance_;
class CDictionaryColor;
struct CDictionaryColorDefaultTypeInternal;
extern CDictionaryColorDefaultTypeInternal _CDictionaryColor_default_instance_;
class CEcad;
struct CEcadDefaultTypeInternal;
extern CEcadDefaultTypeInternal _CEcad_default_instance_;
class CEntryColor;
struct CEntryColorDefaultTypeInternal;
extern CEntryColorDefaultTypeInternal _CEntryColor_default_instance_;
class CGeneral;
struct CGeneralDefaultTypeInternal;
extern CGeneralDefaultTypeInternal _CGeneral_default_instance_;
class CLayer;
struct CLayerDefaultTypeInternal;
extern CLayerDefaultTypeInternal _CLayer_default_instance_;
class CLayerRef;
struct CLayerRefDefaultTypeInternal;
extern CLayerRefDefaultTypeInternal _CLayerRef_default_instance_;
class CProperty;
struct CPropertyDefaultTypeInternal;
extern CPropertyDefaultTypeInternal _CProperty_default_instance_;
class CSpec;
struct CSpecDefaultTypeInternal;
extern CSpecDefaultTypeInternal _CSpec_default_instance_;
class CSpecRef;
struct CSpecRefDefaultTypeInternal;
extern CSpecRefDefaultTypeInternal _CSpecRef_default_instance_;
class CStackup;
struct CStackupDefaultTypeInternal;
extern CStackupDefaultTypeInternal _CStackup_default_instance_;
class CStackupGroup;
struct CStackupGroupDefaultTypeInternal;
extern CStackupGroupDefaultTypeInternal _CStackupGroup_default_instance_;
class CStackupLayer;
struct CStackupLayerDefaultTypeInternal;
extern CStackupLayerDefaultTypeInternal _CStackupLayer_default_instance_;
class root;
struct rootDefaultTypeInternal;
extern rootDefaultTypeInternal _root_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CCadData* Arena::CreateMaybeMessage<::CCadData>(Arena*);
template<> ::CCadHeader* Arena::CreateMaybeMessage<::CCadHeader>(Arena*);
template<> ::CColor* Arena::CreateMaybeMessage<::CColor>(Arena*);
template<> ::CContent* Arena::CreateMaybeMessage<::CContent>(Arena*);
template<> ::CDictionaryColor* Arena::CreateMaybeMessage<::CDictionaryColor>(Arena*);
template<> ::CEcad* Arena::CreateMaybeMessage<::CEcad>(Arena*);
template<> ::CEntryColor* Arena::CreateMaybeMessage<::CEntryColor>(Arena*);
template<> ::CGeneral* Arena::CreateMaybeMessage<::CGeneral>(Arena*);
template<> ::CLayer* Arena::CreateMaybeMessage<::CLayer>(Arena*);
template<> ::CLayerRef* Arena::CreateMaybeMessage<::CLayerRef>(Arena*);
template<> ::CProperty* Arena::CreateMaybeMessage<::CProperty>(Arena*);
template<> ::CSpec* Arena::CreateMaybeMessage<::CSpec>(Arena*);
template<> ::CSpecRef* Arena::CreateMaybeMessage<::CSpecRef>(Arena*);
template<> ::CStackup* Arena::CreateMaybeMessage<::CStackup>(Arena*);
template<> ::CStackupGroup* Arena::CreateMaybeMessage<::CStackupGroup>(Arena*);
template<> ::CStackupLayer* Arena::CreateMaybeMessage<::CStackupLayer>(Arena*);
template<> ::root* Arena::CreateMaybeMessage<::root>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CGeneralType : int {
  MATERIAL = 0,
  CONDUCITIVITY = 1,
  CGeneralType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CGeneralType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CGeneralType_IsValid(int value);
constexpr CGeneralType CGeneralType_MIN = MATERIAL;
constexpr CGeneralType CGeneralType_MAX = CONDUCITIVITY;
constexpr int CGeneralType_ARRAYSIZE = CGeneralType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CGeneralType_descriptor();
template<typename T>
inline const std::string& CGeneralType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CGeneralType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CGeneralType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CGeneralType_descriptor(), enum_t_value);
}
inline bool CGeneralType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CGeneralType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CGeneralType>(
    CGeneralType_descriptor(), name, value);
}
enum CUnits : int {
  MICRON = 0,
  CUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CUnits_IsValid(int value);
constexpr CUnits CUnits_MIN = MICRON;
constexpr CUnits CUnits_MAX = MICRON;
constexpr int CUnits_ARRAYSIZE = CUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CUnits_descriptor();
template<typename T>
inline const std::string& CUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CUnits_descriptor(), enum_t_value);
}
inline bool CUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CUnits>(
    CUnits_descriptor(), name, value);
}
// ===================================================================

class CLayerRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CLayerRef) */ {
 public:
  inline CLayerRef() : CLayerRef(nullptr) {}
  ~CLayerRef() override;
  explicit PROTOBUF_CONSTEXPR CLayerRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLayerRef(const CLayerRef& from);
  CLayerRef(CLayerRef&& from) noexcept
    : CLayerRef() {
    *this = ::std::move(from);
  }

  inline CLayerRef& operator=(const CLayerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLayerRef& operator=(CLayerRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLayerRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLayerRef* internal_default_instance() {
    return reinterpret_cast<const CLayerRef*>(
               &_CLayerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CLayerRef& a, CLayerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(CLayerRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLayerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CLayerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CLayerRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLayerRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CLayerRef& from) {
    CLayerRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLayerRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CLayerRef";
  }
  protected:
  explicit CLayerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:CLayerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CColor) */ {
 public:
  inline CColor() : CColor(nullptr) {}
  ~CColor() override;
  explicit PROTOBUF_CONSTEXPR CColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CColor(const CColor& from);
  CColor(CColor&& from) noexcept
    : CColor() {
    *this = ::std::move(from);
  }

  inline CColor& operator=(const CColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CColor& operator=(CColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CColor* internal_default_instance() {
    return reinterpret_cast<const CColor*>(
               &_CColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CColor& a, CColor& b) {
    a.Swap(&b);
  }
  inline void Swap(CColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CColor& from) {
    CColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CColor";
  }
  protected:
  explicit CColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // uint32 r = 1;
  void clear_r();
  uint32_t r() const;
  void set_r(uint32_t value);
  private:
  uint32_t _internal_r() const;
  void _internal_set_r(uint32_t value);
  public:

  // uint32 g = 2;
  void clear_g();
  uint32_t g() const;
  void set_g(uint32_t value);
  private:
  uint32_t _internal_g() const;
  void _internal_set_g(uint32_t value);
  public:

  // uint32 b = 3;
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t r_;
    uint32_t g_;
    uint32_t b_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CEntryColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CEntryColor) */ {
 public:
  inline CEntryColor() : CEntryColor(nullptr) {}
  ~CEntryColor() override;
  explicit PROTOBUF_CONSTEXPR CEntryColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CEntryColor(const CEntryColor& from);
  CEntryColor(CEntryColor&& from) noexcept
    : CEntryColor() {
    *this = ::std::move(from);
  }

  inline CEntryColor& operator=(const CEntryColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CEntryColor& operator=(CEntryColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CEntryColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CEntryColor* internal_default_instance() {
    return reinterpret_cast<const CEntryColor*>(
               &_CEntryColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CEntryColor& a, CEntryColor& b) {
    a.Swap(&b);
  }
  inline void Swap(CEntryColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CEntryColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CEntryColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CEntryColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CEntryColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CEntryColor& from) {
    CEntryColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CEntryColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CEntryColor";
  }
  protected:
  explicit CEntryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kColorFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .CColor Color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::CColor& color() const;
  PROTOBUF_NODISCARD ::CColor* release_color();
  ::CColor* mutable_color();
  void set_allocated_color(::CColor* color);
  private:
  const ::CColor& _internal_color() const;
  ::CColor* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::CColor* color);
  ::CColor* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:CEntryColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::CColor* color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CDictionaryColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDictionaryColor) */ {
 public:
  inline CDictionaryColor() : CDictionaryColor(nullptr) {}
  ~CDictionaryColor() override;
  explicit PROTOBUF_CONSTEXPR CDictionaryColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDictionaryColor(const CDictionaryColor& from);
  CDictionaryColor(CDictionaryColor&& from) noexcept
    : CDictionaryColor() {
    *this = ::std::move(from);
  }

  inline CDictionaryColor& operator=(const CDictionaryColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDictionaryColor& operator=(CDictionaryColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDictionaryColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDictionaryColor* internal_default_instance() {
    return reinterpret_cast<const CDictionaryColor*>(
               &_CDictionaryColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CDictionaryColor& a, CDictionaryColor& b) {
    a.Swap(&b);
  }
  inline void Swap(CDictionaryColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDictionaryColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDictionaryColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDictionaryColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDictionaryColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDictionaryColor& from) {
    CDictionaryColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDictionaryColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDictionaryColor";
  }
  protected:
  explicit CDictionaryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryColorFieldNumber = 1,
  };
  // repeated .CEntryColor entry_color = 1;
  int entry_color_size() const;
  private:
  int _internal_entry_color_size() const;
  public:
  void clear_entry_color();
  ::CEntryColor* mutable_entry_color(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CEntryColor >*
      mutable_entry_color();
  private:
  const ::CEntryColor& _internal_entry_color(int index) const;
  ::CEntryColor* _internal_add_entry_color();
  public:
  const ::CEntryColor& entry_color(int index) const;
  ::CEntryColor* add_entry_color();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CEntryColor >&
      entry_color() const;

  // @@protoc_insertion_point(class_scope:CDictionaryColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CEntryColor > entry_color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CContent) */ {
 public:
  inline CContent() : CContent(nullptr) {}
  ~CContent() override;
  explicit PROTOBUF_CONSTEXPR CContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CContent(const CContent& from);
  CContent(CContent&& from) noexcept
    : CContent() {
    *this = ::std::move(from);
  }

  inline CContent& operator=(const CContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CContent& operator=(CContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CContent* internal_default_instance() {
    return reinterpret_cast<const CContent*>(
               &_CContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CContent& a, CContent& b) {
    a.Swap(&b);
  }
  inline void Swap(CContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CContent& from) {
    CContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CContent";
  }
  protected:
  explicit CContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerRefFieldNumber = 1,
    kDictionaryColorFieldNumber = 2,
  };
  // repeated .CLayerRef LayerRef = 1;
  int layerref_size() const;
  private:
  int _internal_layerref_size() const;
  public:
  void clear_layerref();
  ::CLayerRef* mutable_layerref(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayerRef >*
      mutable_layerref();
  private:
  const ::CLayerRef& _internal_layerref(int index) const;
  ::CLayerRef* _internal_add_layerref();
  public:
  const ::CLayerRef& layerref(int index) const;
  ::CLayerRef* add_layerref();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayerRef >&
      layerref() const;

  // .CDictionaryColor DictionaryColor = 2;
  bool has_dictionarycolor() const;
  private:
  bool _internal_has_dictionarycolor() const;
  public:
  void clear_dictionarycolor();
  const ::CDictionaryColor& dictionarycolor() const;
  PROTOBUF_NODISCARD ::CDictionaryColor* release_dictionarycolor();
  ::CDictionaryColor* mutable_dictionarycolor();
  void set_allocated_dictionarycolor(::CDictionaryColor* dictionarycolor);
  private:
  const ::CDictionaryColor& _internal_dictionarycolor() const;
  ::CDictionaryColor* _internal_mutable_dictionarycolor();
  public:
  void unsafe_arena_set_allocated_dictionarycolor(
      ::CDictionaryColor* dictionarycolor);
  ::CDictionaryColor* unsafe_arena_release_dictionarycolor();

  // @@protoc_insertion_point(class_scope:CContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayerRef > layerref_;
    ::CDictionaryColor* dictionarycolor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CProperty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CProperty) */ {
 public:
  inline CProperty() : CProperty(nullptr) {}
  ~CProperty() override;
  explicit PROTOBUF_CONSTEXPR CProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CProperty(const CProperty& from);
  CProperty(CProperty&& from) noexcept
    : CProperty() {
    *this = ::std::move(from);
  }

  inline CProperty& operator=(const CProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline CProperty& operator=(CProperty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CProperty& default_instance() {
    return *internal_default_instance();
  }
  static inline const CProperty* internal_default_instance() {
    return reinterpret_cast<const CProperty*>(
               &_CProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CProperty& a, CProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(CProperty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CProperty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CProperty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CProperty& from) {
    CProperty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CProperty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CProperty";
  }
  protected:
  explicit CProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kUnitFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string unit = 2;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // double value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:CProperty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    double value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CGeneral final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGeneral) */ {
 public:
  inline CGeneral() : CGeneral(nullptr) {}
  ~CGeneral() override;
  explicit PROTOBUF_CONSTEXPR CGeneral(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGeneral(const CGeneral& from);
  CGeneral(CGeneral&& from) noexcept
    : CGeneral() {
    *this = ::std::move(from);
  }

  inline CGeneral& operator=(const CGeneral& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGeneral& operator=(CGeneral&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGeneral& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGeneral* internal_default_instance() {
    return reinterpret_cast<const CGeneral*>(
               &_CGeneral_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CGeneral& a, CGeneral& b) {
    a.Swap(&b);
  }
  inline void Swap(CGeneral* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGeneral* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGeneral* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGeneral>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGeneral& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGeneral& from) {
    CGeneral::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGeneral* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGeneral";
  }
  protected:
  explicit CGeneral(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 2,
    kGeneralFieldNumber = 1,
  };
  // .CProperty Property = 2;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const ::CProperty& property() const;
  PROTOBUF_NODISCARD ::CProperty* release_property();
  ::CProperty* mutable_property();
  void set_allocated_property(::CProperty* property);
  private:
  const ::CProperty& _internal_property() const;
  ::CProperty* _internal_mutable_property();
  public:
  void unsafe_arena_set_allocated_property(
      ::CProperty* property);
  ::CProperty* unsafe_arena_release_property();

  // .CGeneralType General = 1;
  void clear_general();
  ::CGeneralType general() const;
  void set_general(::CGeneralType value);
  private:
  ::CGeneralType _internal_general() const;
  void _internal_set_general(::CGeneralType value);
  public:

  // @@protoc_insertion_point(class_scope:CGeneral)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CProperty* property_;
    int general_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSpec) */ {
 public:
  inline CSpec() : CSpec(nullptr) {}
  ~CSpec() override;
  explicit PROTOBUF_CONSTEXPR CSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSpec(const CSpec& from);
  CSpec(CSpec&& from) noexcept
    : CSpec() {
    *this = ::std::move(from);
  }

  inline CSpec& operator=(const CSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSpec& operator=(CSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSpec* internal_default_instance() {
    return reinterpret_cast<const CSpec*>(
               &_CSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSpec& a, CSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(CSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSpec& from) {
    CSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSpec";
  }
  protected:
  explicit CSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneralFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .CGeneral General = 2;
  int general_size() const;
  private:
  int _internal_general_size() const;
  public:
  void clear_general();
  ::CGeneral* mutable_general(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGeneral >*
      mutable_general();
  private:
  const ::CGeneral& _internal_general(int index) const;
  ::CGeneral* _internal_add_general();
  public:
  const ::CGeneral& general(int index) const;
  ::CGeneral* add_general();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGeneral >&
      general() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:CSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGeneral > general_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CCadHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCadHeader) */ {
 public:
  inline CCadHeader() : CCadHeader(nullptr) {}
  ~CCadHeader() override;
  explicit PROTOBUF_CONSTEXPR CCadHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCadHeader(const CCadHeader& from);
  CCadHeader(CCadHeader&& from) noexcept
    : CCadHeader() {
    *this = ::std::move(from);
  }

  inline CCadHeader& operator=(const CCadHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCadHeader& operator=(CCadHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCadHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCadHeader* internal_default_instance() {
    return reinterpret_cast<const CCadHeader*>(
               &_CCadHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CCadHeader& a, CCadHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CCadHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCadHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCadHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCadHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCadHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CCadHeader& from) {
    CCadHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCadHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCadHeader";
  }
  protected:
  explicit CCadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 2,
    kUnitsFieldNumber = 1,
  };
  // repeated .CSpec Spec = 2;
  int spec_size() const;
  private:
  int _internal_spec_size() const;
  public:
  void clear_spec();
  ::CSpec* mutable_spec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSpec >*
      mutable_spec();
  private:
  const ::CSpec& _internal_spec(int index) const;
  ::CSpec* _internal_add_spec();
  public:
  const ::CSpec& spec(int index) const;
  ::CSpec* add_spec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSpec >&
      spec() const;

  // .CUnits units = 1;
  void clear_units();
  ::CUnits units() const;
  void set_units(::CUnits value);
  private:
  ::CUnits _internal_units() const;
  void _internal_set_units(::CUnits value);
  public:

  // @@protoc_insertion_point(class_scope:CCadHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSpec > spec_;
    int units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CLayer) */ {
 public:
  inline CLayer() : CLayer(nullptr) {}
  ~CLayer() override;
  explicit PROTOBUF_CONSTEXPR CLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLayer(const CLayer& from);
  CLayer(CLayer&& from) noexcept
    : CLayer() {
    *this = ::std::move(from);
  }

  inline CLayer& operator=(const CLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLayer& operator=(CLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLayer* internal_default_instance() {
    return reinterpret_cast<const CLayer*>(
               &_CLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CLayer& a, CLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CLayer& from) {
    CLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CLayer";
  }
  protected:
  explicit CLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPolarityFieldNumber = 2,
    kSideFieldNumber = 3,
    kLayerFunctionFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string polarity = 2;
  void clear_polarity();
  const std::string& polarity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_polarity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_polarity();
  PROTOBUF_NODISCARD std::string* release_polarity();
  void set_allocated_polarity(std::string* polarity);
  private:
  const std::string& _internal_polarity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_polarity(const std::string& value);
  std::string* _internal_mutable_polarity();
  public:

  // string side = 3;
  void clear_side();
  const std::string& side() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_side(ArgT0&& arg0, ArgT... args);
  std::string* mutable_side();
  PROTOBUF_NODISCARD std::string* release_side();
  void set_allocated_side(std::string* side);
  private:
  const std::string& _internal_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_side(const std::string& value);
  std::string* _internal_mutable_side();
  public:

  // string layerFunction = 4;
  void clear_layerfunction();
  const std::string& layerfunction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layerfunction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layerfunction();
  PROTOBUF_NODISCARD std::string* release_layerfunction();
  void set_allocated_layerfunction(std::string* layerfunction);
  private:
  const std::string& _internal_layerfunction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layerfunction(const std::string& value);
  std::string* _internal_mutable_layerfunction();
  public:

  // @@protoc_insertion_point(class_scope:CLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr polarity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layerfunction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CSpecRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSpecRef) */ {
 public:
  inline CSpecRef() : CSpecRef(nullptr) {}
  ~CSpecRef() override;
  explicit PROTOBUF_CONSTEXPR CSpecRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSpecRef(const CSpecRef& from);
  CSpecRef(CSpecRef&& from) noexcept
    : CSpecRef() {
    *this = ::std::move(from);
  }

  inline CSpecRef& operator=(const CSpecRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSpecRef& operator=(CSpecRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSpecRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSpecRef* internal_default_instance() {
    return reinterpret_cast<const CSpecRef*>(
               &_CSpecRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CSpecRef& a, CSpecRef& b) {
    a.Swap(&b);
  }
  inline void Swap(CSpecRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSpecRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSpecRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSpecRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSpecRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSpecRef& from) {
    CSpecRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSpecRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSpecRef";
  }
  protected:
  explicit CSpecRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:CSpecRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CStackupLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStackupLayer) */ {
 public:
  inline CStackupLayer() : CStackupLayer(nullptr) {}
  ~CStackupLayer() override;
  explicit PROTOBUF_CONSTEXPR CStackupLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStackupLayer(const CStackupLayer& from);
  CStackupLayer(CStackupLayer&& from) noexcept
    : CStackupLayer() {
    *this = ::std::move(from);
  }

  inline CStackupLayer& operator=(const CStackupLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStackupLayer& operator=(CStackupLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStackupLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStackupLayer* internal_default_instance() {
    return reinterpret_cast<const CStackupLayer*>(
               &_CStackupLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CStackupLayer& a, CStackupLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CStackupLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStackupLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStackupLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStackupLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStackupLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CStackupLayer& from) {
    CStackupLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStackupLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStackupLayer";
  }
  protected:
  explicit CStackupLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerOrGroupRefFieldNumber = 4,
    kSpecRefFieldNumber = 5,
    kToMinusFieldNumber = 1,
    kToPlusFieldNumber = 2,
    kSequenceFieldNumber = 3,
  };
  // string layerOrGroupRef = 4;
  void clear_layerorgroupref();
  const std::string& layerorgroupref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layerorgroupref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layerorgroupref();
  PROTOBUF_NODISCARD std::string* release_layerorgroupref();
  void set_allocated_layerorgroupref(std::string* layerorgroupref);
  private:
  const std::string& _internal_layerorgroupref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layerorgroupref(const std::string& value);
  std::string* _internal_mutable_layerorgroupref();
  public:

  // .CSpecRef SpecRef = 5;
  bool has_specref() const;
  private:
  bool _internal_has_specref() const;
  public:
  void clear_specref();
  const ::CSpecRef& specref() const;
  PROTOBUF_NODISCARD ::CSpecRef* release_specref();
  ::CSpecRef* mutable_specref();
  void set_allocated_specref(::CSpecRef* specref);
  private:
  const ::CSpecRef& _internal_specref() const;
  ::CSpecRef* _internal_mutable_specref();
  public:
  void unsafe_arena_set_allocated_specref(
      ::CSpecRef* specref);
  ::CSpecRef* unsafe_arena_release_specref();

  // double toMinus = 1;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 2;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // int32 sequence = 3;
  void clear_sequence();
  int32_t sequence() const;
  void set_sequence(int32_t value);
  private:
  int32_t _internal_sequence() const;
  void _internal_set_sequence(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStackupLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layerorgroupref_;
    ::CSpecRef* specref_;
    double tominus_;
    double toplus_;
    int32_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CStackupGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStackupGroup) */ {
 public:
  inline CStackupGroup() : CStackupGroup(nullptr) {}
  ~CStackupGroup() override;
  explicit PROTOBUF_CONSTEXPR CStackupGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStackupGroup(const CStackupGroup& from);
  CStackupGroup(CStackupGroup&& from) noexcept
    : CStackupGroup() {
    *this = ::std::move(from);
  }

  inline CStackupGroup& operator=(const CStackupGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStackupGroup& operator=(CStackupGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStackupGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStackupGroup* internal_default_instance() {
    return reinterpret_cast<const CStackupGroup*>(
               &_CStackupGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CStackupGroup& a, CStackupGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(CStackupGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStackupGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStackupGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStackupGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStackupGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CStackupGroup& from) {
    CStackupGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStackupGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStackupGroup";
  }
  protected:
  explicit CStackupGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackupLayerFieldNumber = 5,
    kNameFieldNumber = 1,
    kToMinusFieldNumber = 2,
    kToPlusFieldNumber = 3,
    kOverallTicknessFieldNumber = 4,
  };
  // repeated .CStackupLayer stackup_layer = 5;
  int stackup_layer_size() const;
  private:
  int _internal_stackup_layer_size() const;
  public:
  void clear_stackup_layer();
  ::CStackupLayer* mutable_stackup_layer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStackupLayer >*
      mutable_stackup_layer();
  private:
  const ::CStackupLayer& _internal_stackup_layer(int index) const;
  ::CStackupLayer* _internal_add_stackup_layer();
  public:
  const ::CStackupLayer& stackup_layer(int index) const;
  ::CStackupLayer* add_stackup_layer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStackupLayer >&
      stackup_layer() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double toMinus = 2;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 3;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // double overallTickness = 4;
  void clear_overalltickness();
  double overalltickness() const;
  void set_overalltickness(double value);
  private:
  double _internal_overalltickness() const;
  void _internal_set_overalltickness(double value);
  public:

  // @@protoc_insertion_point(class_scope:CStackupGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStackupLayer > stackup_layer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    double tominus_;
    double toplus_;
    double overalltickness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CStackup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStackup) */ {
 public:
  inline CStackup() : CStackup(nullptr) {}
  ~CStackup() override;
  explicit PROTOBUF_CONSTEXPR CStackup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStackup(const CStackup& from);
  CStackup(CStackup&& from) noexcept
    : CStackup() {
    *this = ::std::move(from);
  }

  inline CStackup& operator=(const CStackup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStackup& operator=(CStackup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStackup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStackup* internal_default_instance() {
    return reinterpret_cast<const CStackup*>(
               &_CStackup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CStackup& a, CStackup& b) {
    a.Swap(&b);
  }
  inline void Swap(CStackup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStackup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStackup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStackup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStackup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CStackup& from) {
    CStackup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStackup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStackup";
  }
  protected:
  explicit CStackup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWhereMeasuredFieldNumber = 2,
    kStackupGroupFieldNumber = 6,
    kToMinusFieldNumber = 3,
    kToPlusFieldNumber = 4,
    kOverallTicknessFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string whereMeasured = 2;
  void clear_wheremeasured();
  const std::string& wheremeasured() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wheremeasured(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wheremeasured();
  PROTOBUF_NODISCARD std::string* release_wheremeasured();
  void set_allocated_wheremeasured(std::string* wheremeasured);
  private:
  const std::string& _internal_wheremeasured() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wheremeasured(const std::string& value);
  std::string* _internal_mutable_wheremeasured();
  public:

  // .CStackupGroup StackupGroup = 6;
  bool has_stackupgroup() const;
  private:
  bool _internal_has_stackupgroup() const;
  public:
  void clear_stackupgroup();
  const ::CStackupGroup& stackupgroup() const;
  PROTOBUF_NODISCARD ::CStackupGroup* release_stackupgroup();
  ::CStackupGroup* mutable_stackupgroup();
  void set_allocated_stackupgroup(::CStackupGroup* stackupgroup);
  private:
  const ::CStackupGroup& _internal_stackupgroup() const;
  ::CStackupGroup* _internal_mutable_stackupgroup();
  public:
  void unsafe_arena_set_allocated_stackupgroup(
      ::CStackupGroup* stackupgroup);
  ::CStackupGroup* unsafe_arena_release_stackupgroup();

  // double toMinus = 3;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 4;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // double overallTickness = 5;
  void clear_overalltickness();
  double overalltickness() const;
  void set_overalltickness(double value);
  private:
  double _internal_overalltickness() const;
  void _internal_set_overalltickness(double value);
  public:

  // @@protoc_insertion_point(class_scope:CStackup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wheremeasured_;
    ::CStackupGroup* stackupgroup_;
    double tominus_;
    double toplus_;
    double overalltickness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CCadData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCadData) */ {
 public:
  inline CCadData() : CCadData(nullptr) {}
  ~CCadData() override;
  explicit PROTOBUF_CONSTEXPR CCadData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCadData(const CCadData& from);
  CCadData(CCadData&& from) noexcept
    : CCadData() {
    *this = ::std::move(from);
  }

  inline CCadData& operator=(const CCadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCadData& operator=(CCadData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCadData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCadData* internal_default_instance() {
    return reinterpret_cast<const CCadData*>(
               &_CCadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CCadData& a, CCadData& b) {
    a.Swap(&b);
  }
  inline void Swap(CCadData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCadData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCadData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CCadData& from) {
    CCadData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCadData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCadData";
  }
  protected:
  explicit CCadData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kStackupFieldNumber = 2,
  };
  // repeated .CLayer Layer = 1;
  int layer_size() const;
  private:
  int _internal_layer_size() const;
  public:
  void clear_layer();
  ::CLayer* mutable_layer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayer >*
      mutable_layer();
  private:
  const ::CLayer& _internal_layer(int index) const;
  ::CLayer* _internal_add_layer();
  public:
  const ::CLayer& layer(int index) const;
  ::CLayer* add_layer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayer >&
      layer() const;

  // .CStackup Stackup = 2;
  bool has_stackup() const;
  private:
  bool _internal_has_stackup() const;
  public:
  void clear_stackup();
  const ::CStackup& stackup() const;
  PROTOBUF_NODISCARD ::CStackup* release_stackup();
  ::CStackup* mutable_stackup();
  void set_allocated_stackup(::CStackup* stackup);
  private:
  const ::CStackup& _internal_stackup() const;
  ::CStackup* _internal_mutable_stackup();
  public:
  void unsafe_arena_set_allocated_stackup(
      ::CStackup* stackup);
  ::CStackup* unsafe_arena_release_stackup();

  // @@protoc_insertion_point(class_scope:CCadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayer > layer_;
    ::CStackup* stackup_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CEcad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CEcad) */ {
 public:
  inline CEcad() : CEcad(nullptr) {}
  ~CEcad() override;
  explicit PROTOBUF_CONSTEXPR CEcad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CEcad(const CEcad& from);
  CEcad(CEcad&& from) noexcept
    : CEcad() {
    *this = ::std::move(from);
  }

  inline CEcad& operator=(const CEcad& from) {
    CopyFrom(from);
    return *this;
  }
  inline CEcad& operator=(CEcad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CEcad& default_instance() {
    return *internal_default_instance();
  }
  static inline const CEcad* internal_default_instance() {
    return reinterpret_cast<const CEcad*>(
               &_CEcad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CEcad& a, CEcad& b) {
    a.Swap(&b);
  }
  inline void Swap(CEcad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CEcad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CEcad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CEcad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CEcad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CEcad& from) {
    CEcad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CEcad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CEcad";
  }
  protected:
  explicit CEcad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCadHeaderFieldNumber = 2,
    kCadDataFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .CCadHeader CadHeader = 2;
  bool has_cadheader() const;
  private:
  bool _internal_has_cadheader() const;
  public:
  void clear_cadheader();
  const ::CCadHeader& cadheader() const;
  PROTOBUF_NODISCARD ::CCadHeader* release_cadheader();
  ::CCadHeader* mutable_cadheader();
  void set_allocated_cadheader(::CCadHeader* cadheader);
  private:
  const ::CCadHeader& _internal_cadheader() const;
  ::CCadHeader* _internal_mutable_cadheader();
  public:
  void unsafe_arena_set_allocated_cadheader(
      ::CCadHeader* cadheader);
  ::CCadHeader* unsafe_arena_release_cadheader();

  // .CCadData CadData = 3;
  bool has_caddata() const;
  private:
  bool _internal_has_caddata() const;
  public:
  void clear_caddata();
  const ::CCadData& caddata() const;
  PROTOBUF_NODISCARD ::CCadData* release_caddata();
  ::CCadData* mutable_caddata();
  void set_allocated_caddata(::CCadData* caddata);
  private:
  const ::CCadData& _internal_caddata() const;
  ::CCadData* _internal_mutable_caddata();
  public:
  void unsafe_arena_set_allocated_caddata(
      ::CCadData* caddata);
  ::CCadData* unsafe_arena_release_caddata();

  // @@protoc_insertion_point(class_scope:CEcad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CCadHeader* cadheader_;
    ::CCadData* caddata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class root final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:root) */ {
 public:
  inline root() : root(nullptr) {}
  ~root() override;
  explicit PROTOBUF_CONSTEXPR root(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  root(const root& from);
  root(root&& from) noexcept
    : root() {
    *this = ::std::move(from);
  }

  inline root& operator=(const root& from) {
    CopyFrom(from);
    return *this;
  }
  inline root& operator=(root&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const root& default_instance() {
    return *internal_default_instance();
  }
  static inline const root* internal_default_instance() {
    return reinterpret_cast<const root*>(
               &_root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(root& a, root& b) {
    a.Swap(&b);
  }
  inline void Swap(root* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(root* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  root* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<root>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const root& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const root& from) {
    root::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(root* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "root";
  }
  protected:
  explicit root(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
    kEcadFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .CContent Content = 2;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::CContent& content() const;
  PROTOBUF_NODISCARD ::CContent* release_content();
  ::CContent* mutable_content();
  void set_allocated_content(::CContent* content);
  private:
  const ::CContent& _internal_content() const;
  ::CContent* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::CContent* content);
  ::CContent* unsafe_arena_release_content();

  // .CEcad Ecad = 3;
  bool has_ecad() const;
  private:
  bool _internal_has_ecad() const;
  public:
  void clear_ecad();
  const ::CEcad& ecad() const;
  PROTOBUF_NODISCARD ::CEcad* release_ecad();
  ::CEcad* mutable_ecad();
  void set_allocated_ecad(::CEcad* ecad);
  private:
  const ::CEcad& _internal_ecad() const;
  ::CEcad* _internal_mutable_ecad();
  public:
  void unsafe_arena_set_allocated_ecad(
      ::CEcad* ecad);
  ::CEcad* unsafe_arena_release_ecad();

  // @@protoc_insertion_point(class_scope:root)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CContent* content_;
    ::CEcad* ecad_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CLayerRef

// string name = 1;
inline void CLayerRef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CLayerRef::name() const {
  // @@protoc_insertion_point(field_get:CLayerRef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLayerRef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLayerRef.name)
}
inline std::string* CLayerRef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CLayerRef.name)
  return _s;
}
inline const std::string& CLayerRef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CLayerRef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CLayerRef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CLayerRef::release_name() {
  // @@protoc_insertion_point(field_release:CLayerRef.name)
  return _impl_.name_.Release();
}
inline void CLayerRef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLayerRef.name)
}

// -------------------------------------------------------------------

// CColor

// uint32 r = 1;
inline void CColor::clear_r() {
  _impl_.r_ = 0u;
}
inline uint32_t CColor::_internal_r() const {
  return _impl_.r_;
}
inline uint32_t CColor::r() const {
  // @@protoc_insertion_point(field_get:CColor.r)
  return _internal_r();
}
inline void CColor::_internal_set_r(uint32_t value) {
  
  _impl_.r_ = value;
}
inline void CColor::set_r(uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:CColor.r)
}

// uint32 g = 2;
inline void CColor::clear_g() {
  _impl_.g_ = 0u;
}
inline uint32_t CColor::_internal_g() const {
  return _impl_.g_;
}
inline uint32_t CColor::g() const {
  // @@protoc_insertion_point(field_get:CColor.g)
  return _internal_g();
}
inline void CColor::_internal_set_g(uint32_t value) {
  
  _impl_.g_ = value;
}
inline void CColor::set_g(uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:CColor.g)
}

// uint32 b = 3;
inline void CColor::clear_b() {
  _impl_.b_ = 0u;
}
inline uint32_t CColor::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t CColor::b() const {
  // @@protoc_insertion_point(field_get:CColor.b)
  return _internal_b();
}
inline void CColor::_internal_set_b(uint32_t value) {
  
  _impl_.b_ = value;
}
inline void CColor::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:CColor.b)
}

// -------------------------------------------------------------------

// CEntryColor

// string id = 1;
inline void CEntryColor::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CEntryColor::id() const {
  // @@protoc_insertion_point(field_get:CEntryColor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CEntryColor::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CEntryColor.id)
}
inline std::string* CEntryColor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:CEntryColor.id)
  return _s;
}
inline const std::string& CEntryColor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CEntryColor::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CEntryColor::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CEntryColor::release_id() {
  // @@protoc_insertion_point(field_release:CEntryColor.id)
  return _impl_.id_.Release();
}
inline void CEntryColor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CEntryColor.id)
}

// .CColor Color = 2;
inline bool CEntryColor::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool CEntryColor::has_color() const {
  return _internal_has_color();
}
inline void CEntryColor::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::CColor& CEntryColor::_internal_color() const {
  const ::CColor* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::CColor&>(
      ::_CColor_default_instance_);
}
inline const ::CColor& CEntryColor::color() const {
  // @@protoc_insertion_point(field_get:CEntryColor.Color)
  return _internal_color();
}
inline void CEntryColor::unsafe_arena_set_allocated_color(
    ::CColor* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CEntryColor.Color)
}
inline ::CColor* CEntryColor::release_color() {
  
  ::CColor* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CColor* CEntryColor::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:CEntryColor.Color)
  
  ::CColor* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::CColor* CEntryColor::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::CColor>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::CColor* CEntryColor::mutable_color() {
  ::CColor* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:CEntryColor.Color)
  return _msg;
}
inline void CEntryColor::set_allocated_color(::CColor* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:CEntryColor.Color)
}

// -------------------------------------------------------------------

// CDictionaryColor

// repeated .CEntryColor entry_color = 1;
inline int CDictionaryColor::_internal_entry_color_size() const {
  return _impl_.entry_color_.size();
}
inline int CDictionaryColor::entry_color_size() const {
  return _internal_entry_color_size();
}
inline void CDictionaryColor::clear_entry_color() {
  _impl_.entry_color_.Clear();
}
inline ::CEntryColor* CDictionaryColor::mutable_entry_color(int index) {
  // @@protoc_insertion_point(field_mutable:CDictionaryColor.entry_color)
  return _impl_.entry_color_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CEntryColor >*
CDictionaryColor::mutable_entry_color() {
  // @@protoc_insertion_point(field_mutable_list:CDictionaryColor.entry_color)
  return &_impl_.entry_color_;
}
inline const ::CEntryColor& CDictionaryColor::_internal_entry_color(int index) const {
  return _impl_.entry_color_.Get(index);
}
inline const ::CEntryColor& CDictionaryColor::entry_color(int index) const {
  // @@protoc_insertion_point(field_get:CDictionaryColor.entry_color)
  return _internal_entry_color(index);
}
inline ::CEntryColor* CDictionaryColor::_internal_add_entry_color() {
  return _impl_.entry_color_.Add();
}
inline ::CEntryColor* CDictionaryColor::add_entry_color() {
  ::CEntryColor* _add = _internal_add_entry_color();
  // @@protoc_insertion_point(field_add:CDictionaryColor.entry_color)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CEntryColor >&
CDictionaryColor::entry_color() const {
  // @@protoc_insertion_point(field_list:CDictionaryColor.entry_color)
  return _impl_.entry_color_;
}

// -------------------------------------------------------------------

// CContent

// repeated .CLayerRef LayerRef = 1;
inline int CContent::_internal_layerref_size() const {
  return _impl_.layerref_.size();
}
inline int CContent::layerref_size() const {
  return _internal_layerref_size();
}
inline void CContent::clear_layerref() {
  _impl_.layerref_.Clear();
}
inline ::CLayerRef* CContent::mutable_layerref(int index) {
  // @@protoc_insertion_point(field_mutable:CContent.LayerRef)
  return _impl_.layerref_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayerRef >*
CContent::mutable_layerref() {
  // @@protoc_insertion_point(field_mutable_list:CContent.LayerRef)
  return &_impl_.layerref_;
}
inline const ::CLayerRef& CContent::_internal_layerref(int index) const {
  return _impl_.layerref_.Get(index);
}
inline const ::CLayerRef& CContent::layerref(int index) const {
  // @@protoc_insertion_point(field_get:CContent.LayerRef)
  return _internal_layerref(index);
}
inline ::CLayerRef* CContent::_internal_add_layerref() {
  return _impl_.layerref_.Add();
}
inline ::CLayerRef* CContent::add_layerref() {
  ::CLayerRef* _add = _internal_add_layerref();
  // @@protoc_insertion_point(field_add:CContent.LayerRef)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayerRef >&
CContent::layerref() const {
  // @@protoc_insertion_point(field_list:CContent.LayerRef)
  return _impl_.layerref_;
}

// .CDictionaryColor DictionaryColor = 2;
inline bool CContent::_internal_has_dictionarycolor() const {
  return this != internal_default_instance() && _impl_.dictionarycolor_ != nullptr;
}
inline bool CContent::has_dictionarycolor() const {
  return _internal_has_dictionarycolor();
}
inline void CContent::clear_dictionarycolor() {
  if (GetArenaForAllocation() == nullptr && _impl_.dictionarycolor_ != nullptr) {
    delete _impl_.dictionarycolor_;
  }
  _impl_.dictionarycolor_ = nullptr;
}
inline const ::CDictionaryColor& CContent::_internal_dictionarycolor() const {
  const ::CDictionaryColor* p = _impl_.dictionarycolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::CDictionaryColor&>(
      ::_CDictionaryColor_default_instance_);
}
inline const ::CDictionaryColor& CContent::dictionarycolor() const {
  // @@protoc_insertion_point(field_get:CContent.DictionaryColor)
  return _internal_dictionarycolor();
}
inline void CContent::unsafe_arena_set_allocated_dictionarycolor(
    ::CDictionaryColor* dictionarycolor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dictionarycolor_);
  }
  _impl_.dictionarycolor_ = dictionarycolor;
  if (dictionarycolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CContent.DictionaryColor)
}
inline ::CDictionaryColor* CContent::release_dictionarycolor() {
  
  ::CDictionaryColor* temp = _impl_.dictionarycolor_;
  _impl_.dictionarycolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CDictionaryColor* CContent::unsafe_arena_release_dictionarycolor() {
  // @@protoc_insertion_point(field_release:CContent.DictionaryColor)
  
  ::CDictionaryColor* temp = _impl_.dictionarycolor_;
  _impl_.dictionarycolor_ = nullptr;
  return temp;
}
inline ::CDictionaryColor* CContent::_internal_mutable_dictionarycolor() {
  
  if (_impl_.dictionarycolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::CDictionaryColor>(GetArenaForAllocation());
    _impl_.dictionarycolor_ = p;
  }
  return _impl_.dictionarycolor_;
}
inline ::CDictionaryColor* CContent::mutable_dictionarycolor() {
  ::CDictionaryColor* _msg = _internal_mutable_dictionarycolor();
  // @@protoc_insertion_point(field_mutable:CContent.DictionaryColor)
  return _msg;
}
inline void CContent::set_allocated_dictionarycolor(::CDictionaryColor* dictionarycolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dictionarycolor_;
  }
  if (dictionarycolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dictionarycolor);
    if (message_arena != submessage_arena) {
      dictionarycolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictionarycolor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dictionarycolor_ = dictionarycolor;
  // @@protoc_insertion_point(field_set_allocated:CContent.DictionaryColor)
}

// -------------------------------------------------------------------

// CProperty

// string text = 1;
inline void CProperty::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& CProperty::text() const {
  // @@protoc_insertion_point(field_get:CProperty.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CProperty::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CProperty.text)
}
inline std::string* CProperty::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:CProperty.text)
  return _s;
}
inline const std::string& CProperty::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CProperty::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CProperty::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CProperty::release_text() {
  // @@protoc_insertion_point(field_release:CProperty.text)
  return _impl_.text_.Release();
}
inline void CProperty::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CProperty.text)
}

// string unit = 2;
inline void CProperty::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& CProperty::unit() const {
  // @@protoc_insertion_point(field_get:CProperty.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CProperty::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CProperty.unit)
}
inline std::string* CProperty::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:CProperty.unit)
  return _s;
}
inline const std::string& CProperty::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void CProperty::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* CProperty::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* CProperty::release_unit() {
  // @@protoc_insertion_point(field_release:CProperty.unit)
  return _impl_.unit_.Release();
}
inline void CProperty::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CProperty.unit)
}

// double value = 3;
inline void CProperty::clear_value() {
  _impl_.value_ = 0;
}
inline double CProperty::_internal_value() const {
  return _impl_.value_;
}
inline double CProperty::value() const {
  // @@protoc_insertion_point(field_get:CProperty.value)
  return _internal_value();
}
inline void CProperty::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void CProperty::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CProperty.value)
}

// -------------------------------------------------------------------

// CGeneral

// .CGeneralType General = 1;
inline void CGeneral::clear_general() {
  _impl_.general_ = 0;
}
inline ::CGeneralType CGeneral::_internal_general() const {
  return static_cast< ::CGeneralType >(_impl_.general_);
}
inline ::CGeneralType CGeneral::general() const {
  // @@protoc_insertion_point(field_get:CGeneral.General)
  return _internal_general();
}
inline void CGeneral::_internal_set_general(::CGeneralType value) {
  
  _impl_.general_ = value;
}
inline void CGeneral::set_general(::CGeneralType value) {
  _internal_set_general(value);
  // @@protoc_insertion_point(field_set:CGeneral.General)
}

// .CProperty Property = 2;
inline bool CGeneral::_internal_has_property() const {
  return this != internal_default_instance() && _impl_.property_ != nullptr;
}
inline bool CGeneral::has_property() const {
  return _internal_has_property();
}
inline void CGeneral::clear_property() {
  if (GetArenaForAllocation() == nullptr && _impl_.property_ != nullptr) {
    delete _impl_.property_;
  }
  _impl_.property_ = nullptr;
}
inline const ::CProperty& CGeneral::_internal_property() const {
  const ::CProperty* p = _impl_.property_;
  return p != nullptr ? *p : reinterpret_cast<const ::CProperty&>(
      ::_CProperty_default_instance_);
}
inline const ::CProperty& CGeneral::property() const {
  // @@protoc_insertion_point(field_get:CGeneral.Property)
  return _internal_property();
}
inline void CGeneral::unsafe_arena_set_allocated_property(
    ::CProperty* property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.property_);
  }
  _impl_.property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGeneral.Property)
}
inline ::CProperty* CGeneral::release_property() {
  
  ::CProperty* temp = _impl_.property_;
  _impl_.property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CProperty* CGeneral::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_release:CGeneral.Property)
  
  ::CProperty* temp = _impl_.property_;
  _impl_.property_ = nullptr;
  return temp;
}
inline ::CProperty* CGeneral::_internal_mutable_property() {
  
  if (_impl_.property_ == nullptr) {
    auto* p = CreateMaybeMessage<::CProperty>(GetArenaForAllocation());
    _impl_.property_ = p;
  }
  return _impl_.property_;
}
inline ::CProperty* CGeneral::mutable_property() {
  ::CProperty* _msg = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:CGeneral.Property)
  return _msg;
}
inline void CGeneral::set_allocated_property(::CProperty* property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.property_;
  }
  if (property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(property);
    if (message_arena != submessage_arena) {
      property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.property_ = property;
  // @@protoc_insertion_point(field_set_allocated:CGeneral.Property)
}

// -------------------------------------------------------------------

// CSpec

// string name = 1;
inline void CSpec::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CSpec::name() const {
  // @@protoc_insertion_point(field_get:CSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSpec::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSpec.name)
}
inline std::string* CSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSpec.name)
  return _s;
}
inline const std::string& CSpec::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CSpec::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CSpec::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CSpec::release_name() {
  // @@protoc_insertion_point(field_release:CSpec.name)
  return _impl_.name_.Release();
}
inline void CSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSpec.name)
}

// repeated .CGeneral General = 2;
inline int CSpec::_internal_general_size() const {
  return _impl_.general_.size();
}
inline int CSpec::general_size() const {
  return _internal_general_size();
}
inline void CSpec::clear_general() {
  _impl_.general_.Clear();
}
inline ::CGeneral* CSpec::mutable_general(int index) {
  // @@protoc_insertion_point(field_mutable:CSpec.General)
  return _impl_.general_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGeneral >*
CSpec::mutable_general() {
  // @@protoc_insertion_point(field_mutable_list:CSpec.General)
  return &_impl_.general_;
}
inline const ::CGeneral& CSpec::_internal_general(int index) const {
  return _impl_.general_.Get(index);
}
inline const ::CGeneral& CSpec::general(int index) const {
  // @@protoc_insertion_point(field_get:CSpec.General)
  return _internal_general(index);
}
inline ::CGeneral* CSpec::_internal_add_general() {
  return _impl_.general_.Add();
}
inline ::CGeneral* CSpec::add_general() {
  ::CGeneral* _add = _internal_add_general();
  // @@protoc_insertion_point(field_add:CSpec.General)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CGeneral >&
CSpec::general() const {
  // @@protoc_insertion_point(field_list:CSpec.General)
  return _impl_.general_;
}

// -------------------------------------------------------------------

// CCadHeader

// .CUnits units = 1;
inline void CCadHeader::clear_units() {
  _impl_.units_ = 0;
}
inline ::CUnits CCadHeader::_internal_units() const {
  return static_cast< ::CUnits >(_impl_.units_);
}
inline ::CUnits CCadHeader::units() const {
  // @@protoc_insertion_point(field_get:CCadHeader.units)
  return _internal_units();
}
inline void CCadHeader::_internal_set_units(::CUnits value) {
  
  _impl_.units_ = value;
}
inline void CCadHeader::set_units(::CUnits value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:CCadHeader.units)
}

// repeated .CSpec Spec = 2;
inline int CCadHeader::_internal_spec_size() const {
  return _impl_.spec_.size();
}
inline int CCadHeader::spec_size() const {
  return _internal_spec_size();
}
inline void CCadHeader::clear_spec() {
  _impl_.spec_.Clear();
}
inline ::CSpec* CCadHeader::mutable_spec(int index) {
  // @@protoc_insertion_point(field_mutable:CCadHeader.Spec)
  return _impl_.spec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSpec >*
CCadHeader::mutable_spec() {
  // @@protoc_insertion_point(field_mutable_list:CCadHeader.Spec)
  return &_impl_.spec_;
}
inline const ::CSpec& CCadHeader::_internal_spec(int index) const {
  return _impl_.spec_.Get(index);
}
inline const ::CSpec& CCadHeader::spec(int index) const {
  // @@protoc_insertion_point(field_get:CCadHeader.Spec)
  return _internal_spec(index);
}
inline ::CSpec* CCadHeader::_internal_add_spec() {
  return _impl_.spec_.Add();
}
inline ::CSpec* CCadHeader::add_spec() {
  ::CSpec* _add = _internal_add_spec();
  // @@protoc_insertion_point(field_add:CCadHeader.Spec)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSpec >&
CCadHeader::spec() const {
  // @@protoc_insertion_point(field_list:CCadHeader.Spec)
  return _impl_.spec_;
}

// -------------------------------------------------------------------

// CLayer

// string name = 1;
inline void CLayer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CLayer::name() const {
  // @@protoc_insertion_point(field_get:CLayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLayer.name)
}
inline std::string* CLayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CLayer.name)
  return _s;
}
inline const std::string& CLayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CLayer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CLayer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CLayer::release_name() {
  // @@protoc_insertion_point(field_release:CLayer.name)
  return _impl_.name_.Release();
}
inline void CLayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLayer.name)
}

// string polarity = 2;
inline void CLayer::clear_polarity() {
  _impl_.polarity_.ClearToEmpty();
}
inline const std::string& CLayer::polarity() const {
  // @@protoc_insertion_point(field_get:CLayer.polarity)
  return _internal_polarity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLayer::set_polarity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.polarity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLayer.polarity)
}
inline std::string* CLayer::mutable_polarity() {
  std::string* _s = _internal_mutable_polarity();
  // @@protoc_insertion_point(field_mutable:CLayer.polarity)
  return _s;
}
inline const std::string& CLayer::_internal_polarity() const {
  return _impl_.polarity_.Get();
}
inline void CLayer::_internal_set_polarity(const std::string& value) {
  
  _impl_.polarity_.Set(value, GetArenaForAllocation());
}
inline std::string* CLayer::_internal_mutable_polarity() {
  
  return _impl_.polarity_.Mutable(GetArenaForAllocation());
}
inline std::string* CLayer::release_polarity() {
  // @@protoc_insertion_point(field_release:CLayer.polarity)
  return _impl_.polarity_.Release();
}
inline void CLayer::set_allocated_polarity(std::string* polarity) {
  if (polarity != nullptr) {
    
  } else {
    
  }
  _impl_.polarity_.SetAllocated(polarity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.polarity_.IsDefault()) {
    _impl_.polarity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLayer.polarity)
}

// string side = 3;
inline void CLayer::clear_side() {
  _impl_.side_.ClearToEmpty();
}
inline const std::string& CLayer::side() const {
  // @@protoc_insertion_point(field_get:CLayer.side)
  return _internal_side();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLayer::set_side(ArgT0&& arg0, ArgT... args) {
 
 _impl_.side_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLayer.side)
}
inline std::string* CLayer::mutable_side() {
  std::string* _s = _internal_mutable_side();
  // @@protoc_insertion_point(field_mutable:CLayer.side)
  return _s;
}
inline const std::string& CLayer::_internal_side() const {
  return _impl_.side_.Get();
}
inline void CLayer::_internal_set_side(const std::string& value) {
  
  _impl_.side_.Set(value, GetArenaForAllocation());
}
inline std::string* CLayer::_internal_mutable_side() {
  
  return _impl_.side_.Mutable(GetArenaForAllocation());
}
inline std::string* CLayer::release_side() {
  // @@protoc_insertion_point(field_release:CLayer.side)
  return _impl_.side_.Release();
}
inline void CLayer::set_allocated_side(std::string* side) {
  if (side != nullptr) {
    
  } else {
    
  }
  _impl_.side_.SetAllocated(side, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.side_.IsDefault()) {
    _impl_.side_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLayer.side)
}

// string layerFunction = 4;
inline void CLayer::clear_layerfunction() {
  _impl_.layerfunction_.ClearToEmpty();
}
inline const std::string& CLayer::layerfunction() const {
  // @@protoc_insertion_point(field_get:CLayer.layerFunction)
  return _internal_layerfunction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLayer::set_layerfunction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layerfunction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLayer.layerFunction)
}
inline std::string* CLayer::mutable_layerfunction() {
  std::string* _s = _internal_mutable_layerfunction();
  // @@protoc_insertion_point(field_mutable:CLayer.layerFunction)
  return _s;
}
inline const std::string& CLayer::_internal_layerfunction() const {
  return _impl_.layerfunction_.Get();
}
inline void CLayer::_internal_set_layerfunction(const std::string& value) {
  
  _impl_.layerfunction_.Set(value, GetArenaForAllocation());
}
inline std::string* CLayer::_internal_mutable_layerfunction() {
  
  return _impl_.layerfunction_.Mutable(GetArenaForAllocation());
}
inline std::string* CLayer::release_layerfunction() {
  // @@protoc_insertion_point(field_release:CLayer.layerFunction)
  return _impl_.layerfunction_.Release();
}
inline void CLayer::set_allocated_layerfunction(std::string* layerfunction) {
  if (layerfunction != nullptr) {
    
  } else {
    
  }
  _impl_.layerfunction_.SetAllocated(layerfunction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layerfunction_.IsDefault()) {
    _impl_.layerfunction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLayer.layerFunction)
}

// -------------------------------------------------------------------

// CSpecRef

// string id = 1;
inline void CSpecRef::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CSpecRef::id() const {
  // @@protoc_insertion_point(field_get:CSpecRef.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSpecRef::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSpecRef.id)
}
inline std::string* CSpecRef::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:CSpecRef.id)
  return _s;
}
inline const std::string& CSpecRef::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CSpecRef::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CSpecRef::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CSpecRef::release_id() {
  // @@protoc_insertion_point(field_release:CSpecRef.id)
  return _impl_.id_.Release();
}
inline void CSpecRef::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSpecRef.id)
}

// -------------------------------------------------------------------

// CStackupLayer

// double toMinus = 1;
inline void CStackupLayer::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double CStackupLayer::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double CStackupLayer::tominus() const {
  // @@protoc_insertion_point(field_get:CStackupLayer.toMinus)
  return _internal_tominus();
}
inline void CStackupLayer::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void CStackupLayer::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:CStackupLayer.toMinus)
}

// double toPlus = 2;
inline void CStackupLayer::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double CStackupLayer::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double CStackupLayer::toplus() const {
  // @@protoc_insertion_point(field_get:CStackupLayer.toPlus)
  return _internal_toplus();
}
inline void CStackupLayer::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void CStackupLayer::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:CStackupLayer.toPlus)
}

// int32 sequence = 3;
inline void CStackupLayer::clear_sequence() {
  _impl_.sequence_ = 0;
}
inline int32_t CStackupLayer::_internal_sequence() const {
  return _impl_.sequence_;
}
inline int32_t CStackupLayer::sequence() const {
  // @@protoc_insertion_point(field_get:CStackupLayer.sequence)
  return _internal_sequence();
}
inline void CStackupLayer::_internal_set_sequence(int32_t value) {
  
  _impl_.sequence_ = value;
}
inline void CStackupLayer::set_sequence(int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:CStackupLayer.sequence)
}

// string layerOrGroupRef = 4;
inline void CStackupLayer::clear_layerorgroupref() {
  _impl_.layerorgroupref_.ClearToEmpty();
}
inline const std::string& CStackupLayer::layerorgroupref() const {
  // @@protoc_insertion_point(field_get:CStackupLayer.layerOrGroupRef)
  return _internal_layerorgroupref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStackupLayer::set_layerorgroupref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layerorgroupref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStackupLayer.layerOrGroupRef)
}
inline std::string* CStackupLayer::mutable_layerorgroupref() {
  std::string* _s = _internal_mutable_layerorgroupref();
  // @@protoc_insertion_point(field_mutable:CStackupLayer.layerOrGroupRef)
  return _s;
}
inline const std::string& CStackupLayer::_internal_layerorgroupref() const {
  return _impl_.layerorgroupref_.Get();
}
inline void CStackupLayer::_internal_set_layerorgroupref(const std::string& value) {
  
  _impl_.layerorgroupref_.Set(value, GetArenaForAllocation());
}
inline std::string* CStackupLayer::_internal_mutable_layerorgroupref() {
  
  return _impl_.layerorgroupref_.Mutable(GetArenaForAllocation());
}
inline std::string* CStackupLayer::release_layerorgroupref() {
  // @@protoc_insertion_point(field_release:CStackupLayer.layerOrGroupRef)
  return _impl_.layerorgroupref_.Release();
}
inline void CStackupLayer::set_allocated_layerorgroupref(std::string* layerorgroupref) {
  if (layerorgroupref != nullptr) {
    
  } else {
    
  }
  _impl_.layerorgroupref_.SetAllocated(layerorgroupref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layerorgroupref_.IsDefault()) {
    _impl_.layerorgroupref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStackupLayer.layerOrGroupRef)
}

// .CSpecRef SpecRef = 5;
inline bool CStackupLayer::_internal_has_specref() const {
  return this != internal_default_instance() && _impl_.specref_ != nullptr;
}
inline bool CStackupLayer::has_specref() const {
  return _internal_has_specref();
}
inline void CStackupLayer::clear_specref() {
  if (GetArenaForAllocation() == nullptr && _impl_.specref_ != nullptr) {
    delete _impl_.specref_;
  }
  _impl_.specref_ = nullptr;
}
inline const ::CSpecRef& CStackupLayer::_internal_specref() const {
  const ::CSpecRef* p = _impl_.specref_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSpecRef&>(
      ::_CSpecRef_default_instance_);
}
inline const ::CSpecRef& CStackupLayer::specref() const {
  // @@protoc_insertion_point(field_get:CStackupLayer.SpecRef)
  return _internal_specref();
}
inline void CStackupLayer::unsafe_arena_set_allocated_specref(
    ::CSpecRef* specref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.specref_);
  }
  _impl_.specref_ = specref;
  if (specref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStackupLayer.SpecRef)
}
inline ::CSpecRef* CStackupLayer::release_specref() {
  
  ::CSpecRef* temp = _impl_.specref_;
  _impl_.specref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSpecRef* CStackupLayer::unsafe_arena_release_specref() {
  // @@protoc_insertion_point(field_release:CStackupLayer.SpecRef)
  
  ::CSpecRef* temp = _impl_.specref_;
  _impl_.specref_ = nullptr;
  return temp;
}
inline ::CSpecRef* CStackupLayer::_internal_mutable_specref() {
  
  if (_impl_.specref_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSpecRef>(GetArenaForAllocation());
    _impl_.specref_ = p;
  }
  return _impl_.specref_;
}
inline ::CSpecRef* CStackupLayer::mutable_specref() {
  ::CSpecRef* _msg = _internal_mutable_specref();
  // @@protoc_insertion_point(field_mutable:CStackupLayer.SpecRef)
  return _msg;
}
inline void CStackupLayer::set_allocated_specref(::CSpecRef* specref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.specref_;
  }
  if (specref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(specref);
    if (message_arena != submessage_arena) {
      specref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specref, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.specref_ = specref;
  // @@protoc_insertion_point(field_set_allocated:CStackupLayer.SpecRef)
}

// -------------------------------------------------------------------

// CStackupGroup

// string name = 1;
inline void CStackupGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CStackupGroup::name() const {
  // @@protoc_insertion_point(field_get:CStackupGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStackupGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStackupGroup.name)
}
inline std::string* CStackupGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CStackupGroup.name)
  return _s;
}
inline const std::string& CStackupGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CStackupGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CStackupGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CStackupGroup::release_name() {
  // @@protoc_insertion_point(field_release:CStackupGroup.name)
  return _impl_.name_.Release();
}
inline void CStackupGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStackupGroup.name)
}

// double toMinus = 2;
inline void CStackupGroup::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double CStackupGroup::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double CStackupGroup::tominus() const {
  // @@protoc_insertion_point(field_get:CStackupGroup.toMinus)
  return _internal_tominus();
}
inline void CStackupGroup::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void CStackupGroup::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:CStackupGroup.toMinus)
}

// double toPlus = 3;
inline void CStackupGroup::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double CStackupGroup::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double CStackupGroup::toplus() const {
  // @@protoc_insertion_point(field_get:CStackupGroup.toPlus)
  return _internal_toplus();
}
inline void CStackupGroup::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void CStackupGroup::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:CStackupGroup.toPlus)
}

// double overallTickness = 4;
inline void CStackupGroup::clear_overalltickness() {
  _impl_.overalltickness_ = 0;
}
inline double CStackupGroup::_internal_overalltickness() const {
  return _impl_.overalltickness_;
}
inline double CStackupGroup::overalltickness() const {
  // @@protoc_insertion_point(field_get:CStackupGroup.overallTickness)
  return _internal_overalltickness();
}
inline void CStackupGroup::_internal_set_overalltickness(double value) {
  
  _impl_.overalltickness_ = value;
}
inline void CStackupGroup::set_overalltickness(double value) {
  _internal_set_overalltickness(value);
  // @@protoc_insertion_point(field_set:CStackupGroup.overallTickness)
}

// repeated .CStackupLayer stackup_layer = 5;
inline int CStackupGroup::_internal_stackup_layer_size() const {
  return _impl_.stackup_layer_.size();
}
inline int CStackupGroup::stackup_layer_size() const {
  return _internal_stackup_layer_size();
}
inline void CStackupGroup::clear_stackup_layer() {
  _impl_.stackup_layer_.Clear();
}
inline ::CStackupLayer* CStackupGroup::mutable_stackup_layer(int index) {
  // @@protoc_insertion_point(field_mutable:CStackupGroup.stackup_layer)
  return _impl_.stackup_layer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStackupLayer >*
CStackupGroup::mutable_stackup_layer() {
  // @@protoc_insertion_point(field_mutable_list:CStackupGroup.stackup_layer)
  return &_impl_.stackup_layer_;
}
inline const ::CStackupLayer& CStackupGroup::_internal_stackup_layer(int index) const {
  return _impl_.stackup_layer_.Get(index);
}
inline const ::CStackupLayer& CStackupGroup::stackup_layer(int index) const {
  // @@protoc_insertion_point(field_get:CStackupGroup.stackup_layer)
  return _internal_stackup_layer(index);
}
inline ::CStackupLayer* CStackupGroup::_internal_add_stackup_layer() {
  return _impl_.stackup_layer_.Add();
}
inline ::CStackupLayer* CStackupGroup::add_stackup_layer() {
  ::CStackupLayer* _add = _internal_add_stackup_layer();
  // @@protoc_insertion_point(field_add:CStackupGroup.stackup_layer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStackupLayer >&
CStackupGroup::stackup_layer() const {
  // @@protoc_insertion_point(field_list:CStackupGroup.stackup_layer)
  return _impl_.stackup_layer_;
}

// -------------------------------------------------------------------

// CStackup

// string name = 1;
inline void CStackup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CStackup::name() const {
  // @@protoc_insertion_point(field_get:CStackup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStackup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStackup.name)
}
inline std::string* CStackup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CStackup.name)
  return _s;
}
inline const std::string& CStackup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CStackup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CStackup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CStackup::release_name() {
  // @@protoc_insertion_point(field_release:CStackup.name)
  return _impl_.name_.Release();
}
inline void CStackup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStackup.name)
}

// string whereMeasured = 2;
inline void CStackup::clear_wheremeasured() {
  _impl_.wheremeasured_.ClearToEmpty();
}
inline const std::string& CStackup::wheremeasured() const {
  // @@protoc_insertion_point(field_get:CStackup.whereMeasured)
  return _internal_wheremeasured();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStackup::set_wheremeasured(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wheremeasured_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStackup.whereMeasured)
}
inline std::string* CStackup::mutable_wheremeasured() {
  std::string* _s = _internal_mutable_wheremeasured();
  // @@protoc_insertion_point(field_mutable:CStackup.whereMeasured)
  return _s;
}
inline const std::string& CStackup::_internal_wheremeasured() const {
  return _impl_.wheremeasured_.Get();
}
inline void CStackup::_internal_set_wheremeasured(const std::string& value) {
  
  _impl_.wheremeasured_.Set(value, GetArenaForAllocation());
}
inline std::string* CStackup::_internal_mutable_wheremeasured() {
  
  return _impl_.wheremeasured_.Mutable(GetArenaForAllocation());
}
inline std::string* CStackup::release_wheremeasured() {
  // @@protoc_insertion_point(field_release:CStackup.whereMeasured)
  return _impl_.wheremeasured_.Release();
}
inline void CStackup::set_allocated_wheremeasured(std::string* wheremeasured) {
  if (wheremeasured != nullptr) {
    
  } else {
    
  }
  _impl_.wheremeasured_.SetAllocated(wheremeasured, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wheremeasured_.IsDefault()) {
    _impl_.wheremeasured_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStackup.whereMeasured)
}

// double toMinus = 3;
inline void CStackup::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double CStackup::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double CStackup::tominus() const {
  // @@protoc_insertion_point(field_get:CStackup.toMinus)
  return _internal_tominus();
}
inline void CStackup::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void CStackup::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:CStackup.toMinus)
}

// double toPlus = 4;
inline void CStackup::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double CStackup::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double CStackup::toplus() const {
  // @@protoc_insertion_point(field_get:CStackup.toPlus)
  return _internal_toplus();
}
inline void CStackup::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void CStackup::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:CStackup.toPlus)
}

// double overallTickness = 5;
inline void CStackup::clear_overalltickness() {
  _impl_.overalltickness_ = 0;
}
inline double CStackup::_internal_overalltickness() const {
  return _impl_.overalltickness_;
}
inline double CStackup::overalltickness() const {
  // @@protoc_insertion_point(field_get:CStackup.overallTickness)
  return _internal_overalltickness();
}
inline void CStackup::_internal_set_overalltickness(double value) {
  
  _impl_.overalltickness_ = value;
}
inline void CStackup::set_overalltickness(double value) {
  _internal_set_overalltickness(value);
  // @@protoc_insertion_point(field_set:CStackup.overallTickness)
}

// .CStackupGroup StackupGroup = 6;
inline bool CStackup::_internal_has_stackupgroup() const {
  return this != internal_default_instance() && _impl_.stackupgroup_ != nullptr;
}
inline bool CStackup::has_stackupgroup() const {
  return _internal_has_stackupgroup();
}
inline void CStackup::clear_stackupgroup() {
  if (GetArenaForAllocation() == nullptr && _impl_.stackupgroup_ != nullptr) {
    delete _impl_.stackupgroup_;
  }
  _impl_.stackupgroup_ = nullptr;
}
inline const ::CStackupGroup& CStackup::_internal_stackupgroup() const {
  const ::CStackupGroup* p = _impl_.stackupgroup_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStackupGroup&>(
      ::_CStackupGroup_default_instance_);
}
inline const ::CStackupGroup& CStackup::stackupgroup() const {
  // @@protoc_insertion_point(field_get:CStackup.StackupGroup)
  return _internal_stackupgroup();
}
inline void CStackup::unsafe_arena_set_allocated_stackupgroup(
    ::CStackupGroup* stackupgroup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stackupgroup_);
  }
  _impl_.stackupgroup_ = stackupgroup;
  if (stackupgroup) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStackup.StackupGroup)
}
inline ::CStackupGroup* CStackup::release_stackupgroup() {
  
  ::CStackupGroup* temp = _impl_.stackupgroup_;
  _impl_.stackupgroup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStackupGroup* CStackup::unsafe_arena_release_stackupgroup() {
  // @@protoc_insertion_point(field_release:CStackup.StackupGroup)
  
  ::CStackupGroup* temp = _impl_.stackupgroup_;
  _impl_.stackupgroup_ = nullptr;
  return temp;
}
inline ::CStackupGroup* CStackup::_internal_mutable_stackupgroup() {
  
  if (_impl_.stackupgroup_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStackupGroup>(GetArenaForAllocation());
    _impl_.stackupgroup_ = p;
  }
  return _impl_.stackupgroup_;
}
inline ::CStackupGroup* CStackup::mutable_stackupgroup() {
  ::CStackupGroup* _msg = _internal_mutable_stackupgroup();
  // @@protoc_insertion_point(field_mutable:CStackup.StackupGroup)
  return _msg;
}
inline void CStackup::set_allocated_stackupgroup(::CStackupGroup* stackupgroup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stackupgroup_;
  }
  if (stackupgroup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stackupgroup);
    if (message_arena != submessage_arena) {
      stackupgroup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stackupgroup, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stackupgroup_ = stackupgroup;
  // @@protoc_insertion_point(field_set_allocated:CStackup.StackupGroup)
}

// -------------------------------------------------------------------

// CCadData

// repeated .CLayer Layer = 1;
inline int CCadData::_internal_layer_size() const {
  return _impl_.layer_.size();
}
inline int CCadData::layer_size() const {
  return _internal_layer_size();
}
inline void CCadData::clear_layer() {
  _impl_.layer_.Clear();
}
inline ::CLayer* CCadData::mutable_layer(int index) {
  // @@protoc_insertion_point(field_mutable:CCadData.Layer)
  return _impl_.layer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayer >*
CCadData::mutable_layer() {
  // @@protoc_insertion_point(field_mutable_list:CCadData.Layer)
  return &_impl_.layer_;
}
inline const ::CLayer& CCadData::_internal_layer(int index) const {
  return _impl_.layer_.Get(index);
}
inline const ::CLayer& CCadData::layer(int index) const {
  // @@protoc_insertion_point(field_get:CCadData.Layer)
  return _internal_layer(index);
}
inline ::CLayer* CCadData::_internal_add_layer() {
  return _impl_.layer_.Add();
}
inline ::CLayer* CCadData::add_layer() {
  ::CLayer* _add = _internal_add_layer();
  // @@protoc_insertion_point(field_add:CCadData.Layer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CLayer >&
CCadData::layer() const {
  // @@protoc_insertion_point(field_list:CCadData.Layer)
  return _impl_.layer_;
}

// .CStackup Stackup = 2;
inline bool CCadData::_internal_has_stackup() const {
  return this != internal_default_instance() && _impl_.stackup_ != nullptr;
}
inline bool CCadData::has_stackup() const {
  return _internal_has_stackup();
}
inline void CCadData::clear_stackup() {
  if (GetArenaForAllocation() == nullptr && _impl_.stackup_ != nullptr) {
    delete _impl_.stackup_;
  }
  _impl_.stackup_ = nullptr;
}
inline const ::CStackup& CCadData::_internal_stackup() const {
  const ::CStackup* p = _impl_.stackup_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStackup&>(
      ::_CStackup_default_instance_);
}
inline const ::CStackup& CCadData::stackup() const {
  // @@protoc_insertion_point(field_get:CCadData.Stackup)
  return _internal_stackup();
}
inline void CCadData::unsafe_arena_set_allocated_stackup(
    ::CStackup* stackup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stackup_);
  }
  _impl_.stackup_ = stackup;
  if (stackup) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CCadData.Stackup)
}
inline ::CStackup* CCadData::release_stackup() {
  
  ::CStackup* temp = _impl_.stackup_;
  _impl_.stackup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStackup* CCadData::unsafe_arena_release_stackup() {
  // @@protoc_insertion_point(field_release:CCadData.Stackup)
  
  ::CStackup* temp = _impl_.stackup_;
  _impl_.stackup_ = nullptr;
  return temp;
}
inline ::CStackup* CCadData::_internal_mutable_stackup() {
  
  if (_impl_.stackup_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStackup>(GetArenaForAllocation());
    _impl_.stackup_ = p;
  }
  return _impl_.stackup_;
}
inline ::CStackup* CCadData::mutable_stackup() {
  ::CStackup* _msg = _internal_mutable_stackup();
  // @@protoc_insertion_point(field_mutable:CCadData.Stackup)
  return _msg;
}
inline void CCadData::set_allocated_stackup(::CStackup* stackup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stackup_;
  }
  if (stackup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stackup);
    if (message_arena != submessage_arena) {
      stackup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stackup, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stackup_ = stackup;
  // @@protoc_insertion_point(field_set_allocated:CCadData.Stackup)
}

// -------------------------------------------------------------------

// CEcad

// string name = 1;
inline void CEcad::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CEcad::name() const {
  // @@protoc_insertion_point(field_get:CEcad.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CEcad::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CEcad.name)
}
inline std::string* CEcad::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CEcad.name)
  return _s;
}
inline const std::string& CEcad::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CEcad::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CEcad::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CEcad::release_name() {
  // @@protoc_insertion_point(field_release:CEcad.name)
  return _impl_.name_.Release();
}
inline void CEcad::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CEcad.name)
}

// .CCadHeader CadHeader = 2;
inline bool CEcad::_internal_has_cadheader() const {
  return this != internal_default_instance() && _impl_.cadheader_ != nullptr;
}
inline bool CEcad::has_cadheader() const {
  return _internal_has_cadheader();
}
inline void CEcad::clear_cadheader() {
  if (GetArenaForAllocation() == nullptr && _impl_.cadheader_ != nullptr) {
    delete _impl_.cadheader_;
  }
  _impl_.cadheader_ = nullptr;
}
inline const ::CCadHeader& CEcad::_internal_cadheader() const {
  const ::CCadHeader* p = _impl_.cadheader_;
  return p != nullptr ? *p : reinterpret_cast<const ::CCadHeader&>(
      ::_CCadHeader_default_instance_);
}
inline const ::CCadHeader& CEcad::cadheader() const {
  // @@protoc_insertion_point(field_get:CEcad.CadHeader)
  return _internal_cadheader();
}
inline void CEcad::unsafe_arena_set_allocated_cadheader(
    ::CCadHeader* cadheader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cadheader_);
  }
  _impl_.cadheader_ = cadheader;
  if (cadheader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CEcad.CadHeader)
}
inline ::CCadHeader* CEcad::release_cadheader() {
  
  ::CCadHeader* temp = _impl_.cadheader_;
  _impl_.cadheader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CCadHeader* CEcad::unsafe_arena_release_cadheader() {
  // @@protoc_insertion_point(field_release:CEcad.CadHeader)
  
  ::CCadHeader* temp = _impl_.cadheader_;
  _impl_.cadheader_ = nullptr;
  return temp;
}
inline ::CCadHeader* CEcad::_internal_mutable_cadheader() {
  
  if (_impl_.cadheader_ == nullptr) {
    auto* p = CreateMaybeMessage<::CCadHeader>(GetArenaForAllocation());
    _impl_.cadheader_ = p;
  }
  return _impl_.cadheader_;
}
inline ::CCadHeader* CEcad::mutable_cadheader() {
  ::CCadHeader* _msg = _internal_mutable_cadheader();
  // @@protoc_insertion_point(field_mutable:CEcad.CadHeader)
  return _msg;
}
inline void CEcad::set_allocated_cadheader(::CCadHeader* cadheader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cadheader_;
  }
  if (cadheader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cadheader);
    if (message_arena != submessage_arena) {
      cadheader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cadheader, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cadheader_ = cadheader;
  // @@protoc_insertion_point(field_set_allocated:CEcad.CadHeader)
}

// .CCadData CadData = 3;
inline bool CEcad::_internal_has_caddata() const {
  return this != internal_default_instance() && _impl_.caddata_ != nullptr;
}
inline bool CEcad::has_caddata() const {
  return _internal_has_caddata();
}
inline void CEcad::clear_caddata() {
  if (GetArenaForAllocation() == nullptr && _impl_.caddata_ != nullptr) {
    delete _impl_.caddata_;
  }
  _impl_.caddata_ = nullptr;
}
inline const ::CCadData& CEcad::_internal_caddata() const {
  const ::CCadData* p = _impl_.caddata_;
  return p != nullptr ? *p : reinterpret_cast<const ::CCadData&>(
      ::_CCadData_default_instance_);
}
inline const ::CCadData& CEcad::caddata() const {
  // @@protoc_insertion_point(field_get:CEcad.CadData)
  return _internal_caddata();
}
inline void CEcad::unsafe_arena_set_allocated_caddata(
    ::CCadData* caddata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caddata_);
  }
  _impl_.caddata_ = caddata;
  if (caddata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CEcad.CadData)
}
inline ::CCadData* CEcad::release_caddata() {
  
  ::CCadData* temp = _impl_.caddata_;
  _impl_.caddata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CCadData* CEcad::unsafe_arena_release_caddata() {
  // @@protoc_insertion_point(field_release:CEcad.CadData)
  
  ::CCadData* temp = _impl_.caddata_;
  _impl_.caddata_ = nullptr;
  return temp;
}
inline ::CCadData* CEcad::_internal_mutable_caddata() {
  
  if (_impl_.caddata_ == nullptr) {
    auto* p = CreateMaybeMessage<::CCadData>(GetArenaForAllocation());
    _impl_.caddata_ = p;
  }
  return _impl_.caddata_;
}
inline ::CCadData* CEcad::mutable_caddata() {
  ::CCadData* _msg = _internal_mutable_caddata();
  // @@protoc_insertion_point(field_mutable:CEcad.CadData)
  return _msg;
}
inline void CEcad::set_allocated_caddata(::CCadData* caddata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.caddata_;
  }
  if (caddata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(caddata);
    if (message_arena != submessage_arena) {
      caddata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caddata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.caddata_ = caddata;
  // @@protoc_insertion_point(field_set_allocated:CEcad.CadData)
}

// -------------------------------------------------------------------

// root

// string name = 1;
inline void root::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& root::name() const {
  // @@protoc_insertion_point(field_get:root.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void root::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:root.name)
}
inline std::string* root::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:root.name)
  return _s;
}
inline const std::string& root::_internal_name() const {
  return _impl_.name_.Get();
}
inline void root::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* root::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* root::release_name() {
  // @@protoc_insertion_point(field_release:root.name)
  return _impl_.name_.Release();
}
inline void root::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:root.name)
}

// .CContent Content = 2;
inline bool root::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool root::has_content() const {
  return _internal_has_content();
}
inline void root::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::CContent& root::_internal_content() const {
  const ::CContent* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::CContent&>(
      ::_CContent_default_instance_);
}
inline const ::CContent& root::content() const {
  // @@protoc_insertion_point(field_get:root.Content)
  return _internal_content();
}
inline void root::unsafe_arena_set_allocated_content(
    ::CContent* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:root.Content)
}
inline ::CContent* root::release_content() {
  
  ::CContent* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CContent* root::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:root.Content)
  
  ::CContent* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::CContent* root::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::CContent>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::CContent* root::mutable_content() {
  ::CContent* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:root.Content)
  return _msg;
}
inline void root::set_allocated_content(::CContent* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:root.Content)
}

// .CEcad Ecad = 3;
inline bool root::_internal_has_ecad() const {
  return this != internal_default_instance() && _impl_.ecad_ != nullptr;
}
inline bool root::has_ecad() const {
  return _internal_has_ecad();
}
inline void root::clear_ecad() {
  if (GetArenaForAllocation() == nullptr && _impl_.ecad_ != nullptr) {
    delete _impl_.ecad_;
  }
  _impl_.ecad_ = nullptr;
}
inline const ::CEcad& root::_internal_ecad() const {
  const ::CEcad* p = _impl_.ecad_;
  return p != nullptr ? *p : reinterpret_cast<const ::CEcad&>(
      ::_CEcad_default_instance_);
}
inline const ::CEcad& root::ecad() const {
  // @@protoc_insertion_point(field_get:root.Ecad)
  return _internal_ecad();
}
inline void root::unsafe_arena_set_allocated_ecad(
    ::CEcad* ecad) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ecad_);
  }
  _impl_.ecad_ = ecad;
  if (ecad) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:root.Ecad)
}
inline ::CEcad* root::release_ecad() {
  
  ::CEcad* temp = _impl_.ecad_;
  _impl_.ecad_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CEcad* root::unsafe_arena_release_ecad() {
  // @@protoc_insertion_point(field_release:root.Ecad)
  
  ::CEcad* temp = _impl_.ecad_;
  _impl_.ecad_ = nullptr;
  return temp;
}
inline ::CEcad* root::_internal_mutable_ecad() {
  
  if (_impl_.ecad_ == nullptr) {
    auto* p = CreateMaybeMessage<::CEcad>(GetArenaForAllocation());
    _impl_.ecad_ = p;
  }
  return _impl_.ecad_;
}
inline ::CEcad* root::mutable_ecad() {
  ::CEcad* _msg = _internal_mutable_ecad();
  // @@protoc_insertion_point(field_mutable:root.Ecad)
  return _msg;
}
inline void root::set_allocated_ecad(::CEcad* ecad) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ecad_;
  }
  if (ecad) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ecad);
    if (message_arena != submessage_arena) {
      ecad = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecad, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ecad_ = ecad;
  // @@protoc_insertion_point(field_set_allocated:root.Ecad)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CGeneralType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CGeneralType>() {
  return ::CGeneralType_descriptor();
}
template <> struct is_proto_enum< ::CUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CUnits>() {
  return ::CUnits_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_test_2eproto
