// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_test_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_test_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_test_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_test_2eproto;
class CadData;
struct CadDataDefaultTypeInternal;
extern CadDataDefaultTypeInternal _CadData_default_instance_;
class CadHeader;
struct CadHeaderDefaultTypeInternal;
extern CadHeaderDefaultTypeInternal _CadHeader_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Content;
struct ContentDefaultTypeInternal;
extern ContentDefaultTypeInternal _Content_default_instance_;
class DictionaryColor;
struct DictionaryColorDefaultTypeInternal;
extern DictionaryColorDefaultTypeInternal _DictionaryColor_default_instance_;
class Ecad;
struct EcadDefaultTypeInternal;
extern EcadDefaultTypeInternal _Ecad_default_instance_;
class EntryColor;
struct EntryColorDefaultTypeInternal;
extern EntryColorDefaultTypeInternal _EntryColor_default_instance_;
class General;
struct GeneralDefaultTypeInternal;
extern GeneralDefaultTypeInternal _General_default_instance_;
class Layer;
struct LayerDefaultTypeInternal;
extern LayerDefaultTypeInternal _Layer_default_instance_;
class LayerRef;
struct LayerRefDefaultTypeInternal;
extern LayerRefDefaultTypeInternal _LayerRef_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class Spec;
struct SpecDefaultTypeInternal;
extern SpecDefaultTypeInternal _Spec_default_instance_;
class SpecRef;
struct SpecRefDefaultTypeInternal;
extern SpecRefDefaultTypeInternal _SpecRef_default_instance_;
class Stackup;
struct StackupDefaultTypeInternal;
extern StackupDefaultTypeInternal _Stackup_default_instance_;
class StackupGroup;
struct StackupGroupDefaultTypeInternal;
extern StackupGroupDefaultTypeInternal _StackupGroup_default_instance_;
class StackupLayer;
struct StackupLayerDefaultTypeInternal;
extern StackupLayerDefaultTypeInternal _StackupLayer_default_instance_;
class root;
struct rootDefaultTypeInternal;
extern rootDefaultTypeInternal _root_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CadData* Arena::CreateMaybeMessage<::CadData>(Arena*);
template<> ::CadHeader* Arena::CreateMaybeMessage<::CadHeader>(Arena*);
template<> ::Color* Arena::CreateMaybeMessage<::Color>(Arena*);
template<> ::Content* Arena::CreateMaybeMessage<::Content>(Arena*);
template<> ::DictionaryColor* Arena::CreateMaybeMessage<::DictionaryColor>(Arena*);
template<> ::Ecad* Arena::CreateMaybeMessage<::Ecad>(Arena*);
template<> ::EntryColor* Arena::CreateMaybeMessage<::EntryColor>(Arena*);
template<> ::General* Arena::CreateMaybeMessage<::General>(Arena*);
template<> ::Layer* Arena::CreateMaybeMessage<::Layer>(Arena*);
template<> ::LayerRef* Arena::CreateMaybeMessage<::LayerRef>(Arena*);
template<> ::Property* Arena::CreateMaybeMessage<::Property>(Arena*);
template<> ::Spec* Arena::CreateMaybeMessage<::Spec>(Arena*);
template<> ::SpecRef* Arena::CreateMaybeMessage<::SpecRef>(Arena*);
template<> ::Stackup* Arena::CreateMaybeMessage<::Stackup>(Arena*);
template<> ::StackupGroup* Arena::CreateMaybeMessage<::StackupGroup>(Arena*);
template<> ::StackupLayer* Arena::CreateMaybeMessage<::StackupLayer>(Arena*);
template<> ::root* Arena::CreateMaybeMessage<::root>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum GeneralType : int {
  MATERIAL = 0,
  CONDUCITIVITY = 1,
  GeneralType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GeneralType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GeneralType_IsValid(int value);
constexpr GeneralType GeneralType_MIN = MATERIAL;
constexpr GeneralType GeneralType_MAX = CONDUCITIVITY;
constexpr int GeneralType_ARRAYSIZE = GeneralType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeneralType_descriptor();
template<typename T>
inline const std::string& GeneralType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeneralType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeneralType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeneralType_descriptor(), enum_t_value);
}
inline bool GeneralType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeneralType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeneralType>(
    GeneralType_descriptor(), name, value);
}
enum Units : int {
  MICRON = 0,
  Units_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Units_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Units_IsValid(int value);
constexpr Units Units_MIN = MICRON;
constexpr Units Units_MAX = MICRON;
constexpr int Units_ARRAYSIZE = Units_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Units_descriptor();
template<typename T>
inline const std::string& Units_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Units>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Units_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Units_descriptor(), enum_t_value);
}
inline bool Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Units* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Units>(
    Units_descriptor(), name, value);
}
// ===================================================================

class LayerRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LayerRef) */ {
 public:
  inline LayerRef() : LayerRef(nullptr) {}
  ~LayerRef() override;
  explicit PROTOBUF_CONSTEXPR LayerRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerRef(const LayerRef& from);
  LayerRef(LayerRef&& from) noexcept
    : LayerRef() {
    *this = ::std::move(from);
  }

  inline LayerRef& operator=(const LayerRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerRef& operator=(LayerRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerRef* internal_default_instance() {
    return reinterpret_cast<const LayerRef*>(
               &_LayerRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LayerRef& a, LayerRef& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayerRef& from) {
    LayerRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LayerRef";
  }
  protected:
  explicit LayerRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:LayerRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit PROTOBUF_CONSTEXPR Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Color& from) {
    Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // uint32 r = 1;
  void clear_r();
  uint32_t r() const;
  void set_r(uint32_t value);
  private:
  uint32_t _internal_r() const;
  void _internal_set_r(uint32_t value);
  public:

  // uint32 g = 2;
  void clear_g();
  uint32_t g() const;
  void set_g(uint32_t value);
  private:
  uint32_t _internal_g() const;
  void _internal_set_g(uint32_t value);
  public:

  // uint32 b = 3;
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t r_;
    uint32_t g_;
    uint32_t b_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class EntryColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EntryColor) */ {
 public:
  inline EntryColor() : EntryColor(nullptr) {}
  ~EntryColor() override;
  explicit PROTOBUF_CONSTEXPR EntryColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntryColor(const EntryColor& from);
  EntryColor(EntryColor&& from) noexcept
    : EntryColor() {
    *this = ::std::move(from);
  }

  inline EntryColor& operator=(const EntryColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntryColor& operator=(EntryColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntryColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntryColor* internal_default_instance() {
    return reinterpret_cast<const EntryColor*>(
               &_EntryColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EntryColor& a, EntryColor& b) {
    a.Swap(&b);
  }
  inline void Swap(EntryColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntryColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntryColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntryColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntryColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntryColor& from) {
    EntryColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntryColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EntryColor";
  }
  protected:
  explicit EntryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kColorFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .Color color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  PROTOBUF_NODISCARD ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Color* color);
  ::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:EntryColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::Color* color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class DictionaryColor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DictionaryColor) */ {
 public:
  inline DictionaryColor() : DictionaryColor(nullptr) {}
  ~DictionaryColor() override;
  explicit PROTOBUF_CONSTEXPR DictionaryColor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictionaryColor(const DictionaryColor& from);
  DictionaryColor(DictionaryColor&& from) noexcept
    : DictionaryColor() {
    *this = ::std::move(from);
  }

  inline DictionaryColor& operator=(const DictionaryColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryColor& operator=(DictionaryColor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DictionaryColor& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictionaryColor* internal_default_instance() {
    return reinterpret_cast<const DictionaryColor*>(
               &_DictionaryColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DictionaryColor& a, DictionaryColor& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryColor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictionaryColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictionaryColor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DictionaryColor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DictionaryColor& from) {
    DictionaryColor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictionaryColor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DictionaryColor";
  }
  protected:
  explicit DictionaryColor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryColorFieldNumber = 1,
  };
  // repeated .EntryColor entry_color = 1;
  int entry_color_size() const;
  private:
  int _internal_entry_color_size() const;
  public:
  void clear_entry_color();
  ::EntryColor* mutable_entry_color(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EntryColor >*
      mutable_entry_color();
  private:
  const ::EntryColor& _internal_entry_color(int index) const;
  ::EntryColor* _internal_add_entry_color();
  public:
  const ::EntryColor& entry_color(int index) const;
  ::EntryColor* add_entry_color();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EntryColor >&
      entry_color() const;

  // @@protoc_insertion_point(class_scope:DictionaryColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EntryColor > entry_color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Content final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Content) */ {
 public:
  inline Content() : Content(nullptr) {}
  ~Content() override;
  explicit PROTOBUF_CONSTEXPR Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Content(const Content& from);
  Content(Content&& from) noexcept
    : Content() {
    *this = ::std::move(from);
  }

  inline Content& operator=(const Content& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content& operator=(Content&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Content& default_instance() {
    return *internal_default_instance();
  }
  static inline const Content* internal_default_instance() {
    return reinterpret_cast<const Content*>(
               &_Content_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Content& a, Content& b) {
    a.Swap(&b);
  }
  inline void Swap(Content* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Content* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Content>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Content& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Content& from) {
    Content::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Content* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Content";
  }
  protected:
  explicit Content(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerRefFieldNumber = 1,
    kDictionaryColorFieldNumber = 2,
  };
  // repeated .LayerRef layer_ref = 1;
  int layer_ref_size() const;
  private:
  int _internal_layer_ref_size() const;
  public:
  void clear_layer_ref();
  ::LayerRef* mutable_layer_ref(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerRef >*
      mutable_layer_ref();
  private:
  const ::LayerRef& _internal_layer_ref(int index) const;
  ::LayerRef* _internal_add_layer_ref();
  public:
  const ::LayerRef& layer_ref(int index) const;
  ::LayerRef* add_layer_ref();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerRef >&
      layer_ref() const;

  // .DictionaryColor dictionary_color = 2;
  bool has_dictionary_color() const;
  private:
  bool _internal_has_dictionary_color() const;
  public:
  void clear_dictionary_color();
  const ::DictionaryColor& dictionary_color() const;
  PROTOBUF_NODISCARD ::DictionaryColor* release_dictionary_color();
  ::DictionaryColor* mutable_dictionary_color();
  void set_allocated_dictionary_color(::DictionaryColor* dictionary_color);
  private:
  const ::DictionaryColor& _internal_dictionary_color() const;
  ::DictionaryColor* _internal_mutable_dictionary_color();
  public:
  void unsafe_arena_set_allocated_dictionary_color(
      ::DictionaryColor* dictionary_color);
  ::DictionaryColor* unsafe_arena_release_dictionary_color();

  // @@protoc_insertion_point(class_scope:Content)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerRef > layer_ref_;
    ::DictionaryColor* dictionary_color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Property final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Property) */ {
 public:
  inline Property() : Property(nullptr) {}
  ~Property() override;
  explicit PROTOBUF_CONSTEXPR Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property(const Property& from);
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property& operator=(Property&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }
  inline void Swap(Property* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property& from) {
    Property::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Property";
  }
  protected:
  explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kUnitFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string unit = 2;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // double value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:Property)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    double value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class General final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:General) */ {
 public:
  inline General() : General(nullptr) {}
  ~General() override;
  explicit PROTOBUF_CONSTEXPR General(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  General(const General& from);
  General(General&& from) noexcept
    : General() {
    *this = ::std::move(from);
  }

  inline General& operator=(const General& from) {
    CopyFrom(from);
    return *this;
  }
  inline General& operator=(General&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const General& default_instance() {
    return *internal_default_instance();
  }
  static inline const General* internal_default_instance() {
    return reinterpret_cast<const General*>(
               &_General_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(General& a, General& b) {
    a.Swap(&b);
  }
  inline void Swap(General* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(General* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  General* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<General>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const General& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const General& from) {
    General::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(General* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "General";
  }
  protected:
  explicit General(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 2,
    kGeneralTypeFieldNumber = 1,
  };
  // .Property property = 2;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const ::Property& property() const;
  PROTOBUF_NODISCARD ::Property* release_property();
  ::Property* mutable_property();
  void set_allocated_property(::Property* property);
  private:
  const ::Property& _internal_property() const;
  ::Property* _internal_mutable_property();
  public:
  void unsafe_arena_set_allocated_property(
      ::Property* property);
  ::Property* unsafe_arena_release_property();

  // .GeneralType general_type = 1;
  void clear_general_type();
  ::GeneralType general_type() const;
  void set_general_type(::GeneralType value);
  private:
  ::GeneralType _internal_general_type() const;
  void _internal_set_general_type(::GeneralType value);
  public:

  // @@protoc_insertion_point(class_scope:General)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Property* property_;
    int general_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Spec) */ {
 public:
  inline Spec() : Spec(nullptr) {}
  ~Spec() override;
  explicit PROTOBUF_CONSTEXPR Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Spec(const Spec& from);
  Spec(Spec&& from) noexcept
    : Spec() {
    *this = ::std::move(from);
  }

  inline Spec& operator=(const Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spec& operator=(Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Spec& default_instance() {
    return *internal_default_instance();
  }
  static inline const Spec* internal_default_instance() {
    return reinterpret_cast<const Spec*>(
               &_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Spec& a, Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Spec& from) {
    Spec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Spec";
  }
  protected:
  explicit Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneralFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .General general = 2;
  int general_size() const;
  private:
  int _internal_general_size() const;
  public:
  void clear_general();
  ::General* mutable_general(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::General >*
      mutable_general();
  private:
  const ::General& _internal_general(int index) const;
  ::General* _internal_add_general();
  public:
  const ::General& general(int index) const;
  ::General* add_general();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::General >&
      general() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Spec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::General > general_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CadHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CadHeader) */ {
 public:
  inline CadHeader() : CadHeader(nullptr) {}
  ~CadHeader() override;
  explicit PROTOBUF_CONSTEXPR CadHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CadHeader(const CadHeader& from);
  CadHeader(CadHeader&& from) noexcept
    : CadHeader() {
    *this = ::std::move(from);
  }

  inline CadHeader& operator=(const CadHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CadHeader& operator=(CadHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CadHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CadHeader* internal_default_instance() {
    return reinterpret_cast<const CadHeader*>(
               &_CadHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CadHeader& a, CadHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CadHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CadHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CadHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CadHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CadHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CadHeader& from) {
    CadHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CadHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CadHeader";
  }
  protected:
  explicit CadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 2,
    kUnitsFieldNumber = 1,
  };
  // repeated .Spec spec = 2;
  int spec_size() const;
  private:
  int _internal_spec_size() const;
  public:
  void clear_spec();
  ::Spec* mutable_spec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Spec >*
      mutable_spec();
  private:
  const ::Spec& _internal_spec(int index) const;
  ::Spec* _internal_add_spec();
  public:
  const ::Spec& spec(int index) const;
  ::Spec* add_spec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Spec >&
      spec() const;

  // .Units units = 1;
  void clear_units();
  ::Units units() const;
  void set_units(::Units value);
  private:
  ::Units _internal_units() const;
  void _internal_set_units(::Units value);
  public:

  // @@protoc_insertion_point(class_scope:CadHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Spec > spec_;
    int units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Layer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Layer) */ {
 public:
  inline Layer() : Layer(nullptr) {}
  ~Layer() override;
  explicit PROTOBUF_CONSTEXPR Layer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layer(const Layer& from);
  Layer(Layer&& from) noexcept
    : Layer() {
    *this = ::std::move(from);
  }

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layer& operator=(Layer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layer* internal_default_instance() {
    return reinterpret_cast<const Layer*>(
               &_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Layer& a, Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Layer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Layer& from) {
    Layer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Layer";
  }
  protected:
  explicit Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPolarityFieldNumber = 2,
    kSideFieldNumber = 3,
    kLayerFunctionFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string polarity = 2;
  void clear_polarity();
  const std::string& polarity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_polarity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_polarity();
  PROTOBUF_NODISCARD std::string* release_polarity();
  void set_allocated_polarity(std::string* polarity);
  private:
  const std::string& _internal_polarity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_polarity(const std::string& value);
  std::string* _internal_mutable_polarity();
  public:

  // string side = 3;
  void clear_side();
  const std::string& side() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_side(ArgT0&& arg0, ArgT... args);
  std::string* mutable_side();
  PROTOBUF_NODISCARD std::string* release_side();
  void set_allocated_side(std::string* side);
  private:
  const std::string& _internal_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_side(const std::string& value);
  std::string* _internal_mutable_side();
  public:

  // string layerFunction = 4;
  void clear_layerfunction();
  const std::string& layerfunction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layerfunction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layerfunction();
  PROTOBUF_NODISCARD std::string* release_layerfunction();
  void set_allocated_layerfunction(std::string* layerfunction);
  private:
  const std::string& _internal_layerfunction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layerfunction(const std::string& value);
  std::string* _internal_mutable_layerfunction();
  public:

  // @@protoc_insertion_point(class_scope:Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr polarity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layerfunction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class SpecRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpecRef) */ {
 public:
  inline SpecRef() : SpecRef(nullptr) {}
  ~SpecRef() override;
  explicit PROTOBUF_CONSTEXPR SpecRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecRef(const SpecRef& from);
  SpecRef(SpecRef&& from) noexcept
    : SpecRef() {
    *this = ::std::move(from);
  }

  inline SpecRef& operator=(const SpecRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecRef& operator=(SpecRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecRef* internal_default_instance() {
    return reinterpret_cast<const SpecRef*>(
               &_SpecRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpecRef& a, SpecRef& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpecRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpecRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpecRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpecRef& from) {
    SpecRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpecRef";
  }
  protected:
  explicit SpecRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:SpecRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class StackupLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StackupLayer) */ {
 public:
  inline StackupLayer() : StackupLayer(nullptr) {}
  ~StackupLayer() override;
  explicit PROTOBUF_CONSTEXPR StackupLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StackupLayer(const StackupLayer& from);
  StackupLayer(StackupLayer&& from) noexcept
    : StackupLayer() {
    *this = ::std::move(from);
  }

  inline StackupLayer& operator=(const StackupLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackupLayer& operator=(StackupLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackupLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackupLayer* internal_default_instance() {
    return reinterpret_cast<const StackupLayer*>(
               &_StackupLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StackupLayer& a, StackupLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(StackupLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackupLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackupLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackupLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StackupLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StackupLayer& from) {
    StackupLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackupLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StackupLayer";
  }
  protected:
  explicit StackupLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerOrGroupRefFieldNumber = 4,
    kSpecRefFieldNumber = 5,
    kToMinusFieldNumber = 1,
    kToPlusFieldNumber = 2,
    kSequenceFieldNumber = 3,
  };
  // string layerOrGroupRef = 4;
  void clear_layerorgroupref();
  const std::string& layerorgroupref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layerorgroupref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layerorgroupref();
  PROTOBUF_NODISCARD std::string* release_layerorgroupref();
  void set_allocated_layerorgroupref(std::string* layerorgroupref);
  private:
  const std::string& _internal_layerorgroupref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layerorgroupref(const std::string& value);
  std::string* _internal_mutable_layerorgroupref();
  public:

  // .SpecRef spec_ref = 5;
  bool has_spec_ref() const;
  private:
  bool _internal_has_spec_ref() const;
  public:
  void clear_spec_ref();
  const ::SpecRef& spec_ref() const;
  PROTOBUF_NODISCARD ::SpecRef* release_spec_ref();
  ::SpecRef* mutable_spec_ref();
  void set_allocated_spec_ref(::SpecRef* spec_ref);
  private:
  const ::SpecRef& _internal_spec_ref() const;
  ::SpecRef* _internal_mutable_spec_ref();
  public:
  void unsafe_arena_set_allocated_spec_ref(
      ::SpecRef* spec_ref);
  ::SpecRef* unsafe_arena_release_spec_ref();

  // double toMinus = 1;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 2;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // int32 sequence = 3;
  void clear_sequence();
  int32_t sequence() const;
  void set_sequence(int32_t value);
  private:
  int32_t _internal_sequence() const;
  void _internal_set_sequence(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StackupLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layerorgroupref_;
    ::SpecRef* spec_ref_;
    double tominus_;
    double toplus_;
    int32_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class StackupGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StackupGroup) */ {
 public:
  inline StackupGroup() : StackupGroup(nullptr) {}
  ~StackupGroup() override;
  explicit PROTOBUF_CONSTEXPR StackupGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StackupGroup(const StackupGroup& from);
  StackupGroup(StackupGroup&& from) noexcept
    : StackupGroup() {
    *this = ::std::move(from);
  }

  inline StackupGroup& operator=(const StackupGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackupGroup& operator=(StackupGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackupGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackupGroup* internal_default_instance() {
    return reinterpret_cast<const StackupGroup*>(
               &_StackupGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StackupGroup& a, StackupGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(StackupGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackupGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackupGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackupGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StackupGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StackupGroup& from) {
    StackupGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackupGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StackupGroup";
  }
  protected:
  explicit StackupGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackupLayerFieldNumber = 5,
    kNameFieldNumber = 1,
    kToMinusFieldNumber = 2,
    kToPlusFieldNumber = 3,
    kOverallTicknessFieldNumber = 4,
  };
  // repeated .StackupLayer stackup_layer = 5;
  int stackup_layer_size() const;
  private:
  int _internal_stackup_layer_size() const;
  public:
  void clear_stackup_layer();
  ::StackupLayer* mutable_stackup_layer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StackupLayer >*
      mutable_stackup_layer();
  private:
  const ::StackupLayer& _internal_stackup_layer(int index) const;
  ::StackupLayer* _internal_add_stackup_layer();
  public:
  const ::StackupLayer& stackup_layer(int index) const;
  ::StackupLayer* add_stackup_layer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StackupLayer >&
      stackup_layer() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double toMinus = 2;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 3;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // double overallTickness = 4;
  void clear_overalltickness();
  double overalltickness() const;
  void set_overalltickness(double value);
  private:
  double _internal_overalltickness() const;
  void _internal_set_overalltickness(double value);
  public:

  // @@protoc_insertion_point(class_scope:StackupGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StackupLayer > stackup_layer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    double tominus_;
    double toplus_;
    double overalltickness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Stackup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Stackup) */ {
 public:
  inline Stackup() : Stackup(nullptr) {}
  ~Stackup() override;
  explicit PROTOBUF_CONSTEXPR Stackup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stackup(const Stackup& from);
  Stackup(Stackup&& from) noexcept
    : Stackup() {
    *this = ::std::move(from);
  }

  inline Stackup& operator=(const Stackup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stackup& operator=(Stackup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stackup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stackup* internal_default_instance() {
    return reinterpret_cast<const Stackup*>(
               &_Stackup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Stackup& a, Stackup& b) {
    a.Swap(&b);
  }
  inline void Swap(Stackup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stackup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stackup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stackup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stackup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stackup& from) {
    Stackup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stackup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Stackup";
  }
  protected:
  explicit Stackup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWhereMeasuredFieldNumber = 2,
    kStackGroupFieldNumber = 6,
    kToMinusFieldNumber = 3,
    kToPlusFieldNumber = 4,
    kOverallTicknessFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string whereMeasured = 2;
  void clear_wheremeasured();
  const std::string& wheremeasured() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wheremeasured(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wheremeasured();
  PROTOBUF_NODISCARD std::string* release_wheremeasured();
  void set_allocated_wheremeasured(std::string* wheremeasured);
  private:
  const std::string& _internal_wheremeasured() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wheremeasured(const std::string& value);
  std::string* _internal_mutable_wheremeasured();
  public:

  // .StackupGroup stack_group = 6;
  bool has_stack_group() const;
  private:
  bool _internal_has_stack_group() const;
  public:
  void clear_stack_group();
  const ::StackupGroup& stack_group() const;
  PROTOBUF_NODISCARD ::StackupGroup* release_stack_group();
  ::StackupGroup* mutable_stack_group();
  void set_allocated_stack_group(::StackupGroup* stack_group);
  private:
  const ::StackupGroup& _internal_stack_group() const;
  ::StackupGroup* _internal_mutable_stack_group();
  public:
  void unsafe_arena_set_allocated_stack_group(
      ::StackupGroup* stack_group);
  ::StackupGroup* unsafe_arena_release_stack_group();

  // double toMinus = 3;
  void clear_tominus();
  double tominus() const;
  void set_tominus(double value);
  private:
  double _internal_tominus() const;
  void _internal_set_tominus(double value);
  public:

  // double toPlus = 4;
  void clear_toplus();
  double toplus() const;
  void set_toplus(double value);
  private:
  double _internal_toplus() const;
  void _internal_set_toplus(double value);
  public:

  // double overallTickness = 5;
  void clear_overalltickness();
  double overalltickness() const;
  void set_overalltickness(double value);
  private:
  double _internal_overalltickness() const;
  void _internal_set_overalltickness(double value);
  public:

  // @@protoc_insertion_point(class_scope:Stackup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wheremeasured_;
    ::StackupGroup* stack_group_;
    double tominus_;
    double toplus_;
    double overalltickness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class CadData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CadData) */ {
 public:
  inline CadData() : CadData(nullptr) {}
  ~CadData() override;
  explicit PROTOBUF_CONSTEXPR CadData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CadData(const CadData& from);
  CadData(CadData&& from) noexcept
    : CadData() {
    *this = ::std::move(from);
  }

  inline CadData& operator=(const CadData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CadData& operator=(CadData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CadData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CadData* internal_default_instance() {
    return reinterpret_cast<const CadData*>(
               &_CadData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CadData& a, CadData& b) {
    a.Swap(&b);
  }
  inline void Swap(CadData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CadData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CadData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CadData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CadData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CadData& from) {
    CadData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CadData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CadData";
  }
  protected:
  explicit CadData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kStackUpFieldNumber = 2,
  };
  // repeated .Layer layer = 1;
  int layer_size() const;
  private:
  int _internal_layer_size() const;
  public:
  void clear_layer();
  ::Layer* mutable_layer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Layer >*
      mutable_layer();
  private:
  const ::Layer& _internal_layer(int index) const;
  ::Layer* _internal_add_layer();
  public:
  const ::Layer& layer(int index) const;
  ::Layer* add_layer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Layer >&
      layer() const;

  // .Stackup stack_up = 2;
  bool has_stack_up() const;
  private:
  bool _internal_has_stack_up() const;
  public:
  void clear_stack_up();
  const ::Stackup& stack_up() const;
  PROTOBUF_NODISCARD ::Stackup* release_stack_up();
  ::Stackup* mutable_stack_up();
  void set_allocated_stack_up(::Stackup* stack_up);
  private:
  const ::Stackup& _internal_stack_up() const;
  ::Stackup* _internal_mutable_stack_up();
  public:
  void unsafe_arena_set_allocated_stack_up(
      ::Stackup* stack_up);
  ::Stackup* unsafe_arena_release_stack_up();

  // @@protoc_insertion_point(class_scope:CadData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Layer > layer_;
    ::Stackup* stack_up_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class Ecad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ecad) */ {
 public:
  inline Ecad() : Ecad(nullptr) {}
  ~Ecad() override;
  explicit PROTOBUF_CONSTEXPR Ecad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ecad(const Ecad& from);
  Ecad(Ecad&& from) noexcept
    : Ecad() {
    *this = ::std::move(from);
  }

  inline Ecad& operator=(const Ecad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ecad& operator=(Ecad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ecad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ecad* internal_default_instance() {
    return reinterpret_cast<const Ecad*>(
               &_Ecad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Ecad& a, Ecad& b) {
    a.Swap(&b);
  }
  inline void Swap(Ecad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ecad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ecad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ecad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ecad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ecad& from) {
    Ecad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ecad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ecad";
  }
  protected:
  explicit Ecad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCadHeaderFieldNumber = 2,
    kCadDataFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .CadHeader cad_header = 2;
  bool has_cad_header() const;
  private:
  bool _internal_has_cad_header() const;
  public:
  void clear_cad_header();
  const ::CadHeader& cad_header() const;
  PROTOBUF_NODISCARD ::CadHeader* release_cad_header();
  ::CadHeader* mutable_cad_header();
  void set_allocated_cad_header(::CadHeader* cad_header);
  private:
  const ::CadHeader& _internal_cad_header() const;
  ::CadHeader* _internal_mutable_cad_header();
  public:
  void unsafe_arena_set_allocated_cad_header(
      ::CadHeader* cad_header);
  ::CadHeader* unsafe_arena_release_cad_header();

  // .CadData cad_data = 3;
  bool has_cad_data() const;
  private:
  bool _internal_has_cad_data() const;
  public:
  void clear_cad_data();
  const ::CadData& cad_data() const;
  PROTOBUF_NODISCARD ::CadData* release_cad_data();
  ::CadData* mutable_cad_data();
  void set_allocated_cad_data(::CadData* cad_data);
  private:
  const ::CadData& _internal_cad_data() const;
  ::CadData* _internal_mutable_cad_data();
  public:
  void unsafe_arena_set_allocated_cad_data(
      ::CadData* cad_data);
  ::CadData* unsafe_arena_release_cad_data();

  // @@protoc_insertion_point(class_scope:Ecad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CadHeader* cad_header_;
    ::CadData* cad_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class root final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:root) */ {
 public:
  inline root() : root(nullptr) {}
  ~root() override;
  explicit PROTOBUF_CONSTEXPR root(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  root(const root& from);
  root(root&& from) noexcept
    : root() {
    *this = ::std::move(from);
  }

  inline root& operator=(const root& from) {
    CopyFrom(from);
    return *this;
  }
  inline root& operator=(root&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const root& default_instance() {
    return *internal_default_instance();
  }
  static inline const root* internal_default_instance() {
    return reinterpret_cast<const root*>(
               &_root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(root& a, root& b) {
    a.Swap(&b);
  }
  inline void Swap(root* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(root* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  root* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<root>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const root& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const root& from) {
    root::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(root* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "root";
  }
  protected:
  explicit root(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
    kEcadFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Content content = 2;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::Content& content() const;
  PROTOBUF_NODISCARD ::Content* release_content();
  ::Content* mutable_content();
  void set_allocated_content(::Content* content);
  private:
  const ::Content& _internal_content() const;
  ::Content* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::Content* content);
  ::Content* unsafe_arena_release_content();

  // .Ecad ecad = 3;
  bool has_ecad() const;
  private:
  bool _internal_has_ecad() const;
  public:
  void clear_ecad();
  const ::Ecad& ecad() const;
  PROTOBUF_NODISCARD ::Ecad* release_ecad();
  ::Ecad* mutable_ecad();
  void set_allocated_ecad(::Ecad* ecad);
  private:
  const ::Ecad& _internal_ecad() const;
  ::Ecad* _internal_mutable_ecad();
  public:
  void unsafe_arena_set_allocated_ecad(
      ::Ecad* ecad);
  ::Ecad* unsafe_arena_release_ecad();

  // @@protoc_insertion_point(class_scope:root)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::Content* content_;
    ::Ecad* ecad_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LayerRef

// string name = 1;
inline void LayerRef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LayerRef::name() const {
  // @@protoc_insertion_point(field_get:LayerRef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LayerRef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LayerRef.name)
}
inline std::string* LayerRef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:LayerRef.name)
  return _s;
}
inline const std::string& LayerRef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LayerRef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LayerRef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LayerRef::release_name() {
  // @@protoc_insertion_point(field_release:LayerRef.name)
  return _impl_.name_.Release();
}
inline void LayerRef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LayerRef.name)
}

// -------------------------------------------------------------------

// Color

// uint32 r = 1;
inline void Color::clear_r() {
  _impl_.r_ = 0u;
}
inline uint32_t Color::_internal_r() const {
  return _impl_.r_;
}
inline uint32_t Color::r() const {
  // @@protoc_insertion_point(field_get:Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(uint32_t value) {
  
  _impl_.r_ = value;
}
inline void Color::set_r(uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Color.r)
}

// uint32 g = 2;
inline void Color::clear_g() {
  _impl_.g_ = 0u;
}
inline uint32_t Color::_internal_g() const {
  return _impl_.g_;
}
inline uint32_t Color::g() const {
  // @@protoc_insertion_point(field_get:Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(uint32_t value) {
  
  _impl_.g_ = value;
}
inline void Color::set_g(uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:Color.g)
}

// uint32 b = 3;
inline void Color::clear_b() {
  _impl_.b_ = 0u;
}
inline uint32_t Color::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t Color::b() const {
  // @@protoc_insertion_point(field_get:Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(uint32_t value) {
  
  _impl_.b_ = value;
}
inline void Color::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Color.b)
}

// -------------------------------------------------------------------

// EntryColor

// string id = 1;
inline void EntryColor::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EntryColor::id() const {
  // @@protoc_insertion_point(field_get:EntryColor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntryColor::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EntryColor.id)
}
inline std::string* EntryColor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:EntryColor.id)
  return _s;
}
inline const std::string& EntryColor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EntryColor::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntryColor::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntryColor::release_id() {
  // @@protoc_insertion_point(field_release:EntryColor.id)
  return _impl_.id_.Release();
}
inline void EntryColor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EntryColor.id)
}

// .Color color = 2;
inline bool EntryColor::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool EntryColor::has_color() const {
  return _internal_has_color();
}
inline void EntryColor::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::Color& EntryColor::_internal_color() const {
  const ::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Color&>(
      ::_Color_default_instance_);
}
inline const ::Color& EntryColor::color() const {
  // @@protoc_insertion_point(field_get:EntryColor.color)
  return _internal_color();
}
inline void EntryColor::unsafe_arena_set_allocated_color(
    ::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EntryColor.color)
}
inline ::Color* EntryColor::release_color() {
  
  ::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Color* EntryColor::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:EntryColor.color)
  
  ::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Color* EntryColor::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Color* EntryColor::mutable_color() {
  ::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:EntryColor.color)
  return _msg;
}
inline void EntryColor::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:EntryColor.color)
}

// -------------------------------------------------------------------

// DictionaryColor

// repeated .EntryColor entry_color = 1;
inline int DictionaryColor::_internal_entry_color_size() const {
  return _impl_.entry_color_.size();
}
inline int DictionaryColor::entry_color_size() const {
  return _internal_entry_color_size();
}
inline void DictionaryColor::clear_entry_color() {
  _impl_.entry_color_.Clear();
}
inline ::EntryColor* DictionaryColor::mutable_entry_color(int index) {
  // @@protoc_insertion_point(field_mutable:DictionaryColor.entry_color)
  return _impl_.entry_color_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EntryColor >*
DictionaryColor::mutable_entry_color() {
  // @@protoc_insertion_point(field_mutable_list:DictionaryColor.entry_color)
  return &_impl_.entry_color_;
}
inline const ::EntryColor& DictionaryColor::_internal_entry_color(int index) const {
  return _impl_.entry_color_.Get(index);
}
inline const ::EntryColor& DictionaryColor::entry_color(int index) const {
  // @@protoc_insertion_point(field_get:DictionaryColor.entry_color)
  return _internal_entry_color(index);
}
inline ::EntryColor* DictionaryColor::_internal_add_entry_color() {
  return _impl_.entry_color_.Add();
}
inline ::EntryColor* DictionaryColor::add_entry_color() {
  ::EntryColor* _add = _internal_add_entry_color();
  // @@protoc_insertion_point(field_add:DictionaryColor.entry_color)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EntryColor >&
DictionaryColor::entry_color() const {
  // @@protoc_insertion_point(field_list:DictionaryColor.entry_color)
  return _impl_.entry_color_;
}

// -------------------------------------------------------------------

// Content

// repeated .LayerRef layer_ref = 1;
inline int Content::_internal_layer_ref_size() const {
  return _impl_.layer_ref_.size();
}
inline int Content::layer_ref_size() const {
  return _internal_layer_ref_size();
}
inline void Content::clear_layer_ref() {
  _impl_.layer_ref_.Clear();
}
inline ::LayerRef* Content::mutable_layer_ref(int index) {
  // @@protoc_insertion_point(field_mutable:Content.layer_ref)
  return _impl_.layer_ref_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerRef >*
Content::mutable_layer_ref() {
  // @@protoc_insertion_point(field_mutable_list:Content.layer_ref)
  return &_impl_.layer_ref_;
}
inline const ::LayerRef& Content::_internal_layer_ref(int index) const {
  return _impl_.layer_ref_.Get(index);
}
inline const ::LayerRef& Content::layer_ref(int index) const {
  // @@protoc_insertion_point(field_get:Content.layer_ref)
  return _internal_layer_ref(index);
}
inline ::LayerRef* Content::_internal_add_layer_ref() {
  return _impl_.layer_ref_.Add();
}
inline ::LayerRef* Content::add_layer_ref() {
  ::LayerRef* _add = _internal_add_layer_ref();
  // @@protoc_insertion_point(field_add:Content.layer_ref)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerRef >&
Content::layer_ref() const {
  // @@protoc_insertion_point(field_list:Content.layer_ref)
  return _impl_.layer_ref_;
}

// .DictionaryColor dictionary_color = 2;
inline bool Content::_internal_has_dictionary_color() const {
  return this != internal_default_instance() && _impl_.dictionary_color_ != nullptr;
}
inline bool Content::has_dictionary_color() const {
  return _internal_has_dictionary_color();
}
inline void Content::clear_dictionary_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.dictionary_color_ != nullptr) {
    delete _impl_.dictionary_color_;
  }
  _impl_.dictionary_color_ = nullptr;
}
inline const ::DictionaryColor& Content::_internal_dictionary_color() const {
  const ::DictionaryColor* p = _impl_.dictionary_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::DictionaryColor&>(
      ::_DictionaryColor_default_instance_);
}
inline const ::DictionaryColor& Content::dictionary_color() const {
  // @@protoc_insertion_point(field_get:Content.dictionary_color)
  return _internal_dictionary_color();
}
inline void Content::unsafe_arena_set_allocated_dictionary_color(
    ::DictionaryColor* dictionary_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dictionary_color_);
  }
  _impl_.dictionary_color_ = dictionary_color;
  if (dictionary_color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Content.dictionary_color)
}
inline ::DictionaryColor* Content::release_dictionary_color() {
  
  ::DictionaryColor* temp = _impl_.dictionary_color_;
  _impl_.dictionary_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DictionaryColor* Content::unsafe_arena_release_dictionary_color() {
  // @@protoc_insertion_point(field_release:Content.dictionary_color)
  
  ::DictionaryColor* temp = _impl_.dictionary_color_;
  _impl_.dictionary_color_ = nullptr;
  return temp;
}
inline ::DictionaryColor* Content::_internal_mutable_dictionary_color() {
  
  if (_impl_.dictionary_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::DictionaryColor>(GetArenaForAllocation());
    _impl_.dictionary_color_ = p;
  }
  return _impl_.dictionary_color_;
}
inline ::DictionaryColor* Content::mutable_dictionary_color() {
  ::DictionaryColor* _msg = _internal_mutable_dictionary_color();
  // @@protoc_insertion_point(field_mutable:Content.dictionary_color)
  return _msg;
}
inline void Content::set_allocated_dictionary_color(::DictionaryColor* dictionary_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dictionary_color_;
  }
  if (dictionary_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dictionary_color);
    if (message_arena != submessage_arena) {
      dictionary_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictionary_color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dictionary_color_ = dictionary_color;
  // @@protoc_insertion_point(field_set_allocated:Content.dictionary_color)
}

// -------------------------------------------------------------------

// Property

// string text = 1;
inline void Property::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Property::text() const {
  // @@protoc_insertion_point(field_get:Property.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Property.text)
}
inline std::string* Property::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Property.text)
  return _s;
}
inline const std::string& Property::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Property::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_text() {
  // @@protoc_insertion_point(field_release:Property.text)
  return _impl_.text_.Release();
}
inline void Property::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Property.text)
}

// string unit = 2;
inline void Property::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& Property::unit() const {
  // @@protoc_insertion_point(field_get:Property.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Property.unit)
}
inline std::string* Property::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:Property.unit)
  return _s;
}
inline const std::string& Property::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void Property::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_unit() {
  // @@protoc_insertion_point(field_release:Property.unit)
  return _impl_.unit_.Release();
}
inline void Property::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Property.unit)
}

// double value = 3;
inline void Property::clear_value() {
  _impl_.value_ = 0;
}
inline double Property::_internal_value() const {
  return _impl_.value_;
}
inline double Property::value() const {
  // @@protoc_insertion_point(field_get:Property.value)
  return _internal_value();
}
inline void Property::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void Property::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Property.value)
}

// -------------------------------------------------------------------

// General

// .GeneralType general_type = 1;
inline void General::clear_general_type() {
  _impl_.general_type_ = 0;
}
inline ::GeneralType General::_internal_general_type() const {
  return static_cast< ::GeneralType >(_impl_.general_type_);
}
inline ::GeneralType General::general_type() const {
  // @@protoc_insertion_point(field_get:General.general_type)
  return _internal_general_type();
}
inline void General::_internal_set_general_type(::GeneralType value) {
  
  _impl_.general_type_ = value;
}
inline void General::set_general_type(::GeneralType value) {
  _internal_set_general_type(value);
  // @@protoc_insertion_point(field_set:General.general_type)
}

// .Property property = 2;
inline bool General::_internal_has_property() const {
  return this != internal_default_instance() && _impl_.property_ != nullptr;
}
inline bool General::has_property() const {
  return _internal_has_property();
}
inline void General::clear_property() {
  if (GetArenaForAllocation() == nullptr && _impl_.property_ != nullptr) {
    delete _impl_.property_;
  }
  _impl_.property_ = nullptr;
}
inline const ::Property& General::_internal_property() const {
  const ::Property* p = _impl_.property_;
  return p != nullptr ? *p : reinterpret_cast<const ::Property&>(
      ::_Property_default_instance_);
}
inline const ::Property& General::property() const {
  // @@protoc_insertion_point(field_get:General.property)
  return _internal_property();
}
inline void General::unsafe_arena_set_allocated_property(
    ::Property* property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.property_);
  }
  _impl_.property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:General.property)
}
inline ::Property* General::release_property() {
  
  ::Property* temp = _impl_.property_;
  _impl_.property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Property* General::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_release:General.property)
  
  ::Property* temp = _impl_.property_;
  _impl_.property_ = nullptr;
  return temp;
}
inline ::Property* General::_internal_mutable_property() {
  
  if (_impl_.property_ == nullptr) {
    auto* p = CreateMaybeMessage<::Property>(GetArenaForAllocation());
    _impl_.property_ = p;
  }
  return _impl_.property_;
}
inline ::Property* General::mutable_property() {
  ::Property* _msg = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:General.property)
  return _msg;
}
inline void General::set_allocated_property(::Property* property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.property_;
  }
  if (property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(property);
    if (message_arena != submessage_arena) {
      property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.property_ = property;
  // @@protoc_insertion_point(field_set_allocated:General.property)
}

// -------------------------------------------------------------------

// Spec

// string name = 1;
inline void Spec::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Spec::name() const {
  // @@protoc_insertion_point(field_get:Spec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Spec::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Spec.name)
}
inline std::string* Spec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Spec.name)
  return _s;
}
inline const std::string& Spec::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Spec::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Spec::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Spec::release_name() {
  // @@protoc_insertion_point(field_release:Spec.name)
  return _impl_.name_.Release();
}
inline void Spec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Spec.name)
}

// repeated .General general = 2;
inline int Spec::_internal_general_size() const {
  return _impl_.general_.size();
}
inline int Spec::general_size() const {
  return _internal_general_size();
}
inline void Spec::clear_general() {
  _impl_.general_.Clear();
}
inline ::General* Spec::mutable_general(int index) {
  // @@protoc_insertion_point(field_mutable:Spec.general)
  return _impl_.general_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::General >*
Spec::mutable_general() {
  // @@protoc_insertion_point(field_mutable_list:Spec.general)
  return &_impl_.general_;
}
inline const ::General& Spec::_internal_general(int index) const {
  return _impl_.general_.Get(index);
}
inline const ::General& Spec::general(int index) const {
  // @@protoc_insertion_point(field_get:Spec.general)
  return _internal_general(index);
}
inline ::General* Spec::_internal_add_general() {
  return _impl_.general_.Add();
}
inline ::General* Spec::add_general() {
  ::General* _add = _internal_add_general();
  // @@protoc_insertion_point(field_add:Spec.general)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::General >&
Spec::general() const {
  // @@protoc_insertion_point(field_list:Spec.general)
  return _impl_.general_;
}

// -------------------------------------------------------------------

// CadHeader

// .Units units = 1;
inline void CadHeader::clear_units() {
  _impl_.units_ = 0;
}
inline ::Units CadHeader::_internal_units() const {
  return static_cast< ::Units >(_impl_.units_);
}
inline ::Units CadHeader::units() const {
  // @@protoc_insertion_point(field_get:CadHeader.units)
  return _internal_units();
}
inline void CadHeader::_internal_set_units(::Units value) {
  
  _impl_.units_ = value;
}
inline void CadHeader::set_units(::Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:CadHeader.units)
}

// repeated .Spec spec = 2;
inline int CadHeader::_internal_spec_size() const {
  return _impl_.spec_.size();
}
inline int CadHeader::spec_size() const {
  return _internal_spec_size();
}
inline void CadHeader::clear_spec() {
  _impl_.spec_.Clear();
}
inline ::Spec* CadHeader::mutable_spec(int index) {
  // @@protoc_insertion_point(field_mutable:CadHeader.spec)
  return _impl_.spec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Spec >*
CadHeader::mutable_spec() {
  // @@protoc_insertion_point(field_mutable_list:CadHeader.spec)
  return &_impl_.spec_;
}
inline const ::Spec& CadHeader::_internal_spec(int index) const {
  return _impl_.spec_.Get(index);
}
inline const ::Spec& CadHeader::spec(int index) const {
  // @@protoc_insertion_point(field_get:CadHeader.spec)
  return _internal_spec(index);
}
inline ::Spec* CadHeader::_internal_add_spec() {
  return _impl_.spec_.Add();
}
inline ::Spec* CadHeader::add_spec() {
  ::Spec* _add = _internal_add_spec();
  // @@protoc_insertion_point(field_add:CadHeader.spec)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Spec >&
CadHeader::spec() const {
  // @@protoc_insertion_point(field_list:CadHeader.spec)
  return _impl_.spec_;
}

// -------------------------------------------------------------------

// Layer

// string name = 1;
inline void Layer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Layer::name() const {
  // @@protoc_insertion_point(field_get:Layer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Layer.name)
}
inline std::string* Layer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Layer.name)
  return _s;
}
inline const std::string& Layer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Layer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Layer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Layer::release_name() {
  // @@protoc_insertion_point(field_release:Layer.name)
  return _impl_.name_.Release();
}
inline void Layer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Layer.name)
}

// string polarity = 2;
inline void Layer::clear_polarity() {
  _impl_.polarity_.ClearToEmpty();
}
inline const std::string& Layer::polarity() const {
  // @@protoc_insertion_point(field_get:Layer.polarity)
  return _internal_polarity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layer::set_polarity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.polarity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Layer.polarity)
}
inline std::string* Layer::mutable_polarity() {
  std::string* _s = _internal_mutable_polarity();
  // @@protoc_insertion_point(field_mutable:Layer.polarity)
  return _s;
}
inline const std::string& Layer::_internal_polarity() const {
  return _impl_.polarity_.Get();
}
inline void Layer::_internal_set_polarity(const std::string& value) {
  
  _impl_.polarity_.Set(value, GetArenaForAllocation());
}
inline std::string* Layer::_internal_mutable_polarity() {
  
  return _impl_.polarity_.Mutable(GetArenaForAllocation());
}
inline std::string* Layer::release_polarity() {
  // @@protoc_insertion_point(field_release:Layer.polarity)
  return _impl_.polarity_.Release();
}
inline void Layer::set_allocated_polarity(std::string* polarity) {
  if (polarity != nullptr) {
    
  } else {
    
  }
  _impl_.polarity_.SetAllocated(polarity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.polarity_.IsDefault()) {
    _impl_.polarity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Layer.polarity)
}

// string side = 3;
inline void Layer::clear_side() {
  _impl_.side_.ClearToEmpty();
}
inline const std::string& Layer::side() const {
  // @@protoc_insertion_point(field_get:Layer.side)
  return _internal_side();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layer::set_side(ArgT0&& arg0, ArgT... args) {
 
 _impl_.side_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Layer.side)
}
inline std::string* Layer::mutable_side() {
  std::string* _s = _internal_mutable_side();
  // @@protoc_insertion_point(field_mutable:Layer.side)
  return _s;
}
inline const std::string& Layer::_internal_side() const {
  return _impl_.side_.Get();
}
inline void Layer::_internal_set_side(const std::string& value) {
  
  _impl_.side_.Set(value, GetArenaForAllocation());
}
inline std::string* Layer::_internal_mutable_side() {
  
  return _impl_.side_.Mutable(GetArenaForAllocation());
}
inline std::string* Layer::release_side() {
  // @@protoc_insertion_point(field_release:Layer.side)
  return _impl_.side_.Release();
}
inline void Layer::set_allocated_side(std::string* side) {
  if (side != nullptr) {
    
  } else {
    
  }
  _impl_.side_.SetAllocated(side, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.side_.IsDefault()) {
    _impl_.side_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Layer.side)
}

// string layerFunction = 4;
inline void Layer::clear_layerfunction() {
  _impl_.layerfunction_.ClearToEmpty();
}
inline const std::string& Layer::layerfunction() const {
  // @@protoc_insertion_point(field_get:Layer.layerFunction)
  return _internal_layerfunction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layer::set_layerfunction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layerfunction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Layer.layerFunction)
}
inline std::string* Layer::mutable_layerfunction() {
  std::string* _s = _internal_mutable_layerfunction();
  // @@protoc_insertion_point(field_mutable:Layer.layerFunction)
  return _s;
}
inline const std::string& Layer::_internal_layerfunction() const {
  return _impl_.layerfunction_.Get();
}
inline void Layer::_internal_set_layerfunction(const std::string& value) {
  
  _impl_.layerfunction_.Set(value, GetArenaForAllocation());
}
inline std::string* Layer::_internal_mutable_layerfunction() {
  
  return _impl_.layerfunction_.Mutable(GetArenaForAllocation());
}
inline std::string* Layer::release_layerfunction() {
  // @@protoc_insertion_point(field_release:Layer.layerFunction)
  return _impl_.layerfunction_.Release();
}
inline void Layer::set_allocated_layerfunction(std::string* layerfunction) {
  if (layerfunction != nullptr) {
    
  } else {
    
  }
  _impl_.layerfunction_.SetAllocated(layerfunction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layerfunction_.IsDefault()) {
    _impl_.layerfunction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Layer.layerFunction)
}

// -------------------------------------------------------------------

// SpecRef

// string id = 1;
inline void SpecRef::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SpecRef::id() const {
  // @@protoc_insertion_point(field_get:SpecRef.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpecRef::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SpecRef.id)
}
inline std::string* SpecRef::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SpecRef.id)
  return _s;
}
inline const std::string& SpecRef::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SpecRef::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpecRef::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SpecRef::release_id() {
  // @@protoc_insertion_point(field_release:SpecRef.id)
  return _impl_.id_.Release();
}
inline void SpecRef::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SpecRef.id)
}

// -------------------------------------------------------------------

// StackupLayer

// double toMinus = 1;
inline void StackupLayer::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double StackupLayer::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double StackupLayer::tominus() const {
  // @@protoc_insertion_point(field_get:StackupLayer.toMinus)
  return _internal_tominus();
}
inline void StackupLayer::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void StackupLayer::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:StackupLayer.toMinus)
}

// double toPlus = 2;
inline void StackupLayer::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double StackupLayer::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double StackupLayer::toplus() const {
  // @@protoc_insertion_point(field_get:StackupLayer.toPlus)
  return _internal_toplus();
}
inline void StackupLayer::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void StackupLayer::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:StackupLayer.toPlus)
}

// int32 sequence = 3;
inline void StackupLayer::clear_sequence() {
  _impl_.sequence_ = 0;
}
inline int32_t StackupLayer::_internal_sequence() const {
  return _impl_.sequence_;
}
inline int32_t StackupLayer::sequence() const {
  // @@protoc_insertion_point(field_get:StackupLayer.sequence)
  return _internal_sequence();
}
inline void StackupLayer::_internal_set_sequence(int32_t value) {
  
  _impl_.sequence_ = value;
}
inline void StackupLayer::set_sequence(int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:StackupLayer.sequence)
}

// string layerOrGroupRef = 4;
inline void StackupLayer::clear_layerorgroupref() {
  _impl_.layerorgroupref_.ClearToEmpty();
}
inline const std::string& StackupLayer::layerorgroupref() const {
  // @@protoc_insertion_point(field_get:StackupLayer.layerOrGroupRef)
  return _internal_layerorgroupref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StackupLayer::set_layerorgroupref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layerorgroupref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StackupLayer.layerOrGroupRef)
}
inline std::string* StackupLayer::mutable_layerorgroupref() {
  std::string* _s = _internal_mutable_layerorgroupref();
  // @@protoc_insertion_point(field_mutable:StackupLayer.layerOrGroupRef)
  return _s;
}
inline const std::string& StackupLayer::_internal_layerorgroupref() const {
  return _impl_.layerorgroupref_.Get();
}
inline void StackupLayer::_internal_set_layerorgroupref(const std::string& value) {
  
  _impl_.layerorgroupref_.Set(value, GetArenaForAllocation());
}
inline std::string* StackupLayer::_internal_mutable_layerorgroupref() {
  
  return _impl_.layerorgroupref_.Mutable(GetArenaForAllocation());
}
inline std::string* StackupLayer::release_layerorgroupref() {
  // @@protoc_insertion_point(field_release:StackupLayer.layerOrGroupRef)
  return _impl_.layerorgroupref_.Release();
}
inline void StackupLayer::set_allocated_layerorgroupref(std::string* layerorgroupref) {
  if (layerorgroupref != nullptr) {
    
  } else {
    
  }
  _impl_.layerorgroupref_.SetAllocated(layerorgroupref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layerorgroupref_.IsDefault()) {
    _impl_.layerorgroupref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StackupLayer.layerOrGroupRef)
}

// .SpecRef spec_ref = 5;
inline bool StackupLayer::_internal_has_spec_ref() const {
  return this != internal_default_instance() && _impl_.spec_ref_ != nullptr;
}
inline bool StackupLayer::has_spec_ref() const {
  return _internal_has_spec_ref();
}
inline void StackupLayer::clear_spec_ref() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ref_ != nullptr) {
    delete _impl_.spec_ref_;
  }
  _impl_.spec_ref_ = nullptr;
}
inline const ::SpecRef& StackupLayer::_internal_spec_ref() const {
  const ::SpecRef* p = _impl_.spec_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::SpecRef&>(
      ::_SpecRef_default_instance_);
}
inline const ::SpecRef& StackupLayer::spec_ref() const {
  // @@protoc_insertion_point(field_get:StackupLayer.spec_ref)
  return _internal_spec_ref();
}
inline void StackupLayer::unsafe_arena_set_allocated_spec_ref(
    ::SpecRef* spec_ref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_ref_);
  }
  _impl_.spec_ref_ = spec_ref;
  if (spec_ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StackupLayer.spec_ref)
}
inline ::SpecRef* StackupLayer::release_spec_ref() {
  
  ::SpecRef* temp = _impl_.spec_ref_;
  _impl_.spec_ref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SpecRef* StackupLayer::unsafe_arena_release_spec_ref() {
  // @@protoc_insertion_point(field_release:StackupLayer.spec_ref)
  
  ::SpecRef* temp = _impl_.spec_ref_;
  _impl_.spec_ref_ = nullptr;
  return temp;
}
inline ::SpecRef* StackupLayer::_internal_mutable_spec_ref() {
  
  if (_impl_.spec_ref_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpecRef>(GetArenaForAllocation());
    _impl_.spec_ref_ = p;
  }
  return _impl_.spec_ref_;
}
inline ::SpecRef* StackupLayer::mutable_spec_ref() {
  ::SpecRef* _msg = _internal_mutable_spec_ref();
  // @@protoc_insertion_point(field_mutable:StackupLayer.spec_ref)
  return _msg;
}
inline void StackupLayer::set_allocated_spec_ref(::SpecRef* spec_ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_ref_;
  }
  if (spec_ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec_ref);
    if (message_arena != submessage_arena) {
      spec_ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec_ref, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ref_ = spec_ref;
  // @@protoc_insertion_point(field_set_allocated:StackupLayer.spec_ref)
}

// -------------------------------------------------------------------

// StackupGroup

// string name = 1;
inline void StackupGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StackupGroup::name() const {
  // @@protoc_insertion_point(field_get:StackupGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StackupGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StackupGroup.name)
}
inline std::string* StackupGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:StackupGroup.name)
  return _s;
}
inline const std::string& StackupGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StackupGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StackupGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StackupGroup::release_name() {
  // @@protoc_insertion_point(field_release:StackupGroup.name)
  return _impl_.name_.Release();
}
inline void StackupGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StackupGroup.name)
}

// double toMinus = 2;
inline void StackupGroup::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double StackupGroup::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double StackupGroup::tominus() const {
  // @@protoc_insertion_point(field_get:StackupGroup.toMinus)
  return _internal_tominus();
}
inline void StackupGroup::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void StackupGroup::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:StackupGroup.toMinus)
}

// double toPlus = 3;
inline void StackupGroup::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double StackupGroup::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double StackupGroup::toplus() const {
  // @@protoc_insertion_point(field_get:StackupGroup.toPlus)
  return _internal_toplus();
}
inline void StackupGroup::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void StackupGroup::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:StackupGroup.toPlus)
}

// double overallTickness = 4;
inline void StackupGroup::clear_overalltickness() {
  _impl_.overalltickness_ = 0;
}
inline double StackupGroup::_internal_overalltickness() const {
  return _impl_.overalltickness_;
}
inline double StackupGroup::overalltickness() const {
  // @@protoc_insertion_point(field_get:StackupGroup.overallTickness)
  return _internal_overalltickness();
}
inline void StackupGroup::_internal_set_overalltickness(double value) {
  
  _impl_.overalltickness_ = value;
}
inline void StackupGroup::set_overalltickness(double value) {
  _internal_set_overalltickness(value);
  // @@protoc_insertion_point(field_set:StackupGroup.overallTickness)
}

// repeated .StackupLayer stackup_layer = 5;
inline int StackupGroup::_internal_stackup_layer_size() const {
  return _impl_.stackup_layer_.size();
}
inline int StackupGroup::stackup_layer_size() const {
  return _internal_stackup_layer_size();
}
inline void StackupGroup::clear_stackup_layer() {
  _impl_.stackup_layer_.Clear();
}
inline ::StackupLayer* StackupGroup::mutable_stackup_layer(int index) {
  // @@protoc_insertion_point(field_mutable:StackupGroup.stackup_layer)
  return _impl_.stackup_layer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StackupLayer >*
StackupGroup::mutable_stackup_layer() {
  // @@protoc_insertion_point(field_mutable_list:StackupGroup.stackup_layer)
  return &_impl_.stackup_layer_;
}
inline const ::StackupLayer& StackupGroup::_internal_stackup_layer(int index) const {
  return _impl_.stackup_layer_.Get(index);
}
inline const ::StackupLayer& StackupGroup::stackup_layer(int index) const {
  // @@protoc_insertion_point(field_get:StackupGroup.stackup_layer)
  return _internal_stackup_layer(index);
}
inline ::StackupLayer* StackupGroup::_internal_add_stackup_layer() {
  return _impl_.stackup_layer_.Add();
}
inline ::StackupLayer* StackupGroup::add_stackup_layer() {
  ::StackupLayer* _add = _internal_add_stackup_layer();
  // @@protoc_insertion_point(field_add:StackupGroup.stackup_layer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StackupLayer >&
StackupGroup::stackup_layer() const {
  // @@protoc_insertion_point(field_list:StackupGroup.stackup_layer)
  return _impl_.stackup_layer_;
}

// -------------------------------------------------------------------

// Stackup

// string name = 1;
inline void Stackup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Stackup::name() const {
  // @@protoc_insertion_point(field_get:Stackup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stackup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stackup.name)
}
inline std::string* Stackup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Stackup.name)
  return _s;
}
inline const std::string& Stackup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Stackup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stackup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stackup::release_name() {
  // @@protoc_insertion_point(field_release:Stackup.name)
  return _impl_.name_.Release();
}
inline void Stackup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stackup.name)
}

// string whereMeasured = 2;
inline void Stackup::clear_wheremeasured() {
  _impl_.wheremeasured_.ClearToEmpty();
}
inline const std::string& Stackup::wheremeasured() const {
  // @@protoc_insertion_point(field_get:Stackup.whereMeasured)
  return _internal_wheremeasured();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stackup::set_wheremeasured(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wheremeasured_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stackup.whereMeasured)
}
inline std::string* Stackup::mutable_wheremeasured() {
  std::string* _s = _internal_mutable_wheremeasured();
  // @@protoc_insertion_point(field_mutable:Stackup.whereMeasured)
  return _s;
}
inline const std::string& Stackup::_internal_wheremeasured() const {
  return _impl_.wheremeasured_.Get();
}
inline void Stackup::_internal_set_wheremeasured(const std::string& value) {
  
  _impl_.wheremeasured_.Set(value, GetArenaForAllocation());
}
inline std::string* Stackup::_internal_mutable_wheremeasured() {
  
  return _impl_.wheremeasured_.Mutable(GetArenaForAllocation());
}
inline std::string* Stackup::release_wheremeasured() {
  // @@protoc_insertion_point(field_release:Stackup.whereMeasured)
  return _impl_.wheremeasured_.Release();
}
inline void Stackup::set_allocated_wheremeasured(std::string* wheremeasured) {
  if (wheremeasured != nullptr) {
    
  } else {
    
  }
  _impl_.wheremeasured_.SetAllocated(wheremeasured, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wheremeasured_.IsDefault()) {
    _impl_.wheremeasured_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stackup.whereMeasured)
}

// double toMinus = 3;
inline void Stackup::clear_tominus() {
  _impl_.tominus_ = 0;
}
inline double Stackup::_internal_tominus() const {
  return _impl_.tominus_;
}
inline double Stackup::tominus() const {
  // @@protoc_insertion_point(field_get:Stackup.toMinus)
  return _internal_tominus();
}
inline void Stackup::_internal_set_tominus(double value) {
  
  _impl_.tominus_ = value;
}
inline void Stackup::set_tominus(double value) {
  _internal_set_tominus(value);
  // @@protoc_insertion_point(field_set:Stackup.toMinus)
}

// double toPlus = 4;
inline void Stackup::clear_toplus() {
  _impl_.toplus_ = 0;
}
inline double Stackup::_internal_toplus() const {
  return _impl_.toplus_;
}
inline double Stackup::toplus() const {
  // @@protoc_insertion_point(field_get:Stackup.toPlus)
  return _internal_toplus();
}
inline void Stackup::_internal_set_toplus(double value) {
  
  _impl_.toplus_ = value;
}
inline void Stackup::set_toplus(double value) {
  _internal_set_toplus(value);
  // @@protoc_insertion_point(field_set:Stackup.toPlus)
}

// double overallTickness = 5;
inline void Stackup::clear_overalltickness() {
  _impl_.overalltickness_ = 0;
}
inline double Stackup::_internal_overalltickness() const {
  return _impl_.overalltickness_;
}
inline double Stackup::overalltickness() const {
  // @@protoc_insertion_point(field_get:Stackup.overallTickness)
  return _internal_overalltickness();
}
inline void Stackup::_internal_set_overalltickness(double value) {
  
  _impl_.overalltickness_ = value;
}
inline void Stackup::set_overalltickness(double value) {
  _internal_set_overalltickness(value);
  // @@protoc_insertion_point(field_set:Stackup.overallTickness)
}

// .StackupGroup stack_group = 6;
inline bool Stackup::_internal_has_stack_group() const {
  return this != internal_default_instance() && _impl_.stack_group_ != nullptr;
}
inline bool Stackup::has_stack_group() const {
  return _internal_has_stack_group();
}
inline void Stackup::clear_stack_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.stack_group_ != nullptr) {
    delete _impl_.stack_group_;
  }
  _impl_.stack_group_ = nullptr;
}
inline const ::StackupGroup& Stackup::_internal_stack_group() const {
  const ::StackupGroup* p = _impl_.stack_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::StackupGroup&>(
      ::_StackupGroup_default_instance_);
}
inline const ::StackupGroup& Stackup::stack_group() const {
  // @@protoc_insertion_point(field_get:Stackup.stack_group)
  return _internal_stack_group();
}
inline void Stackup::unsafe_arena_set_allocated_stack_group(
    ::StackupGroup* stack_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stack_group_);
  }
  _impl_.stack_group_ = stack_group;
  if (stack_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stackup.stack_group)
}
inline ::StackupGroup* Stackup::release_stack_group() {
  
  ::StackupGroup* temp = _impl_.stack_group_;
  _impl_.stack_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StackupGroup* Stackup::unsafe_arena_release_stack_group() {
  // @@protoc_insertion_point(field_release:Stackup.stack_group)
  
  ::StackupGroup* temp = _impl_.stack_group_;
  _impl_.stack_group_ = nullptr;
  return temp;
}
inline ::StackupGroup* Stackup::_internal_mutable_stack_group() {
  
  if (_impl_.stack_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::StackupGroup>(GetArenaForAllocation());
    _impl_.stack_group_ = p;
  }
  return _impl_.stack_group_;
}
inline ::StackupGroup* Stackup::mutable_stack_group() {
  ::StackupGroup* _msg = _internal_mutable_stack_group();
  // @@protoc_insertion_point(field_mutable:Stackup.stack_group)
  return _msg;
}
inline void Stackup::set_allocated_stack_group(::StackupGroup* stack_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stack_group_;
  }
  if (stack_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stack_group);
    if (message_arena != submessage_arena) {
      stack_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stack_group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stack_group_ = stack_group;
  // @@protoc_insertion_point(field_set_allocated:Stackup.stack_group)
}

// -------------------------------------------------------------------

// CadData

// repeated .Layer layer = 1;
inline int CadData::_internal_layer_size() const {
  return _impl_.layer_.size();
}
inline int CadData::layer_size() const {
  return _internal_layer_size();
}
inline void CadData::clear_layer() {
  _impl_.layer_.Clear();
}
inline ::Layer* CadData::mutable_layer(int index) {
  // @@protoc_insertion_point(field_mutable:CadData.layer)
  return _impl_.layer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Layer >*
CadData::mutable_layer() {
  // @@protoc_insertion_point(field_mutable_list:CadData.layer)
  return &_impl_.layer_;
}
inline const ::Layer& CadData::_internal_layer(int index) const {
  return _impl_.layer_.Get(index);
}
inline const ::Layer& CadData::layer(int index) const {
  // @@protoc_insertion_point(field_get:CadData.layer)
  return _internal_layer(index);
}
inline ::Layer* CadData::_internal_add_layer() {
  return _impl_.layer_.Add();
}
inline ::Layer* CadData::add_layer() {
  ::Layer* _add = _internal_add_layer();
  // @@protoc_insertion_point(field_add:CadData.layer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Layer >&
CadData::layer() const {
  // @@protoc_insertion_point(field_list:CadData.layer)
  return _impl_.layer_;
}

// .Stackup stack_up = 2;
inline bool CadData::_internal_has_stack_up() const {
  return this != internal_default_instance() && _impl_.stack_up_ != nullptr;
}
inline bool CadData::has_stack_up() const {
  return _internal_has_stack_up();
}
inline void CadData::clear_stack_up() {
  if (GetArenaForAllocation() == nullptr && _impl_.stack_up_ != nullptr) {
    delete _impl_.stack_up_;
  }
  _impl_.stack_up_ = nullptr;
}
inline const ::Stackup& CadData::_internal_stack_up() const {
  const ::Stackup* p = _impl_.stack_up_;
  return p != nullptr ? *p : reinterpret_cast<const ::Stackup&>(
      ::_Stackup_default_instance_);
}
inline const ::Stackup& CadData::stack_up() const {
  // @@protoc_insertion_point(field_get:CadData.stack_up)
  return _internal_stack_up();
}
inline void CadData::unsafe_arena_set_allocated_stack_up(
    ::Stackup* stack_up) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stack_up_);
  }
  _impl_.stack_up_ = stack_up;
  if (stack_up) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CadData.stack_up)
}
inline ::Stackup* CadData::release_stack_up() {
  
  ::Stackup* temp = _impl_.stack_up_;
  _impl_.stack_up_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Stackup* CadData::unsafe_arena_release_stack_up() {
  // @@protoc_insertion_point(field_release:CadData.stack_up)
  
  ::Stackup* temp = _impl_.stack_up_;
  _impl_.stack_up_ = nullptr;
  return temp;
}
inline ::Stackup* CadData::_internal_mutable_stack_up() {
  
  if (_impl_.stack_up_ == nullptr) {
    auto* p = CreateMaybeMessage<::Stackup>(GetArenaForAllocation());
    _impl_.stack_up_ = p;
  }
  return _impl_.stack_up_;
}
inline ::Stackup* CadData::mutable_stack_up() {
  ::Stackup* _msg = _internal_mutable_stack_up();
  // @@protoc_insertion_point(field_mutable:CadData.stack_up)
  return _msg;
}
inline void CadData::set_allocated_stack_up(::Stackup* stack_up) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stack_up_;
  }
  if (stack_up) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stack_up);
    if (message_arena != submessage_arena) {
      stack_up = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stack_up, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stack_up_ = stack_up;
  // @@protoc_insertion_point(field_set_allocated:CadData.stack_up)
}

// -------------------------------------------------------------------

// Ecad

// string name = 1;
inline void Ecad::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Ecad::name() const {
  // @@protoc_insertion_point(field_get:Ecad.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ecad::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Ecad.name)
}
inline std::string* Ecad::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Ecad.name)
  return _s;
}
inline const std::string& Ecad::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Ecad::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Ecad::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Ecad::release_name() {
  // @@protoc_insertion_point(field_release:Ecad.name)
  return _impl_.name_.Release();
}
inline void Ecad::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Ecad.name)
}

// .CadHeader cad_header = 2;
inline bool Ecad::_internal_has_cad_header() const {
  return this != internal_default_instance() && _impl_.cad_header_ != nullptr;
}
inline bool Ecad::has_cad_header() const {
  return _internal_has_cad_header();
}
inline void Ecad::clear_cad_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.cad_header_ != nullptr) {
    delete _impl_.cad_header_;
  }
  _impl_.cad_header_ = nullptr;
}
inline const ::CadHeader& Ecad::_internal_cad_header() const {
  const ::CadHeader* p = _impl_.cad_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::CadHeader&>(
      ::_CadHeader_default_instance_);
}
inline const ::CadHeader& Ecad::cad_header() const {
  // @@protoc_insertion_point(field_get:Ecad.cad_header)
  return _internal_cad_header();
}
inline void Ecad::unsafe_arena_set_allocated_cad_header(
    ::CadHeader* cad_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cad_header_);
  }
  _impl_.cad_header_ = cad_header;
  if (cad_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Ecad.cad_header)
}
inline ::CadHeader* Ecad::release_cad_header() {
  
  ::CadHeader* temp = _impl_.cad_header_;
  _impl_.cad_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CadHeader* Ecad::unsafe_arena_release_cad_header() {
  // @@protoc_insertion_point(field_release:Ecad.cad_header)
  
  ::CadHeader* temp = _impl_.cad_header_;
  _impl_.cad_header_ = nullptr;
  return temp;
}
inline ::CadHeader* Ecad::_internal_mutable_cad_header() {
  
  if (_impl_.cad_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::CadHeader>(GetArenaForAllocation());
    _impl_.cad_header_ = p;
  }
  return _impl_.cad_header_;
}
inline ::CadHeader* Ecad::mutable_cad_header() {
  ::CadHeader* _msg = _internal_mutable_cad_header();
  // @@protoc_insertion_point(field_mutable:Ecad.cad_header)
  return _msg;
}
inline void Ecad::set_allocated_cad_header(::CadHeader* cad_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cad_header_;
  }
  if (cad_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cad_header);
    if (message_arena != submessage_arena) {
      cad_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cad_header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cad_header_ = cad_header;
  // @@protoc_insertion_point(field_set_allocated:Ecad.cad_header)
}

// .CadData cad_data = 3;
inline bool Ecad::_internal_has_cad_data() const {
  return this != internal_default_instance() && _impl_.cad_data_ != nullptr;
}
inline bool Ecad::has_cad_data() const {
  return _internal_has_cad_data();
}
inline void Ecad::clear_cad_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.cad_data_ != nullptr) {
    delete _impl_.cad_data_;
  }
  _impl_.cad_data_ = nullptr;
}
inline const ::CadData& Ecad::_internal_cad_data() const {
  const ::CadData* p = _impl_.cad_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CadData&>(
      ::_CadData_default_instance_);
}
inline const ::CadData& Ecad::cad_data() const {
  // @@protoc_insertion_point(field_get:Ecad.cad_data)
  return _internal_cad_data();
}
inline void Ecad::unsafe_arena_set_allocated_cad_data(
    ::CadData* cad_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cad_data_);
  }
  _impl_.cad_data_ = cad_data;
  if (cad_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Ecad.cad_data)
}
inline ::CadData* Ecad::release_cad_data() {
  
  ::CadData* temp = _impl_.cad_data_;
  _impl_.cad_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CadData* Ecad::unsafe_arena_release_cad_data() {
  // @@protoc_insertion_point(field_release:Ecad.cad_data)
  
  ::CadData* temp = _impl_.cad_data_;
  _impl_.cad_data_ = nullptr;
  return temp;
}
inline ::CadData* Ecad::_internal_mutable_cad_data() {
  
  if (_impl_.cad_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CadData>(GetArenaForAllocation());
    _impl_.cad_data_ = p;
  }
  return _impl_.cad_data_;
}
inline ::CadData* Ecad::mutable_cad_data() {
  ::CadData* _msg = _internal_mutable_cad_data();
  // @@protoc_insertion_point(field_mutable:Ecad.cad_data)
  return _msg;
}
inline void Ecad::set_allocated_cad_data(::CadData* cad_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cad_data_;
  }
  if (cad_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cad_data);
    if (message_arena != submessage_arena) {
      cad_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cad_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cad_data_ = cad_data;
  // @@protoc_insertion_point(field_set_allocated:Ecad.cad_data)
}

// -------------------------------------------------------------------

// root

// string name = 1;
inline void root::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& root::name() const {
  // @@protoc_insertion_point(field_get:root.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void root::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:root.name)
}
inline std::string* root::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:root.name)
  return _s;
}
inline const std::string& root::_internal_name() const {
  return _impl_.name_.Get();
}
inline void root::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* root::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* root::release_name() {
  // @@protoc_insertion_point(field_release:root.name)
  return _impl_.name_.Release();
}
inline void root::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:root.name)
}

// .Content content = 2;
inline bool root::_internal_has_content() const {
  return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool root::has_content() const {
  return _internal_has_content();
}
inline void root::clear_content() {
  if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
    delete _impl_.content_;
  }
  _impl_.content_ = nullptr;
}
inline const ::Content& root::_internal_content() const {
  const ::Content* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::Content&>(
      ::_Content_default_instance_);
}
inline const ::Content& root::content() const {
  // @@protoc_insertion_point(field_get:root.content)
  return _internal_content();
}
inline void root::unsafe_arena_set_allocated_content(
    ::Content* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:root.content)
}
inline ::Content* root::release_content() {
  
  ::Content* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Content* root::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:root.content)
  
  ::Content* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::Content* root::_internal_mutable_content() {
  
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::Content>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::Content* root::mutable_content() {
  ::Content* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:root.content)
  return _msg;
}
inline void root::set_allocated_content(::Content* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:root.content)
}

// .Ecad ecad = 3;
inline bool root::_internal_has_ecad() const {
  return this != internal_default_instance() && _impl_.ecad_ != nullptr;
}
inline bool root::has_ecad() const {
  return _internal_has_ecad();
}
inline void root::clear_ecad() {
  if (GetArenaForAllocation() == nullptr && _impl_.ecad_ != nullptr) {
    delete _impl_.ecad_;
  }
  _impl_.ecad_ = nullptr;
}
inline const ::Ecad& root::_internal_ecad() const {
  const ::Ecad* p = _impl_.ecad_;
  return p != nullptr ? *p : reinterpret_cast<const ::Ecad&>(
      ::_Ecad_default_instance_);
}
inline const ::Ecad& root::ecad() const {
  // @@protoc_insertion_point(field_get:root.ecad)
  return _internal_ecad();
}
inline void root::unsafe_arena_set_allocated_ecad(
    ::Ecad* ecad) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ecad_);
  }
  _impl_.ecad_ = ecad;
  if (ecad) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:root.ecad)
}
inline ::Ecad* root::release_ecad() {
  
  ::Ecad* temp = _impl_.ecad_;
  _impl_.ecad_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Ecad* root::unsafe_arena_release_ecad() {
  // @@protoc_insertion_point(field_release:root.ecad)
  
  ::Ecad* temp = _impl_.ecad_;
  _impl_.ecad_ = nullptr;
  return temp;
}
inline ::Ecad* root::_internal_mutable_ecad() {
  
  if (_impl_.ecad_ == nullptr) {
    auto* p = CreateMaybeMessage<::Ecad>(GetArenaForAllocation());
    _impl_.ecad_ = p;
  }
  return _impl_.ecad_;
}
inline ::Ecad* root::mutable_ecad() {
  ::Ecad* _msg = _internal_mutable_ecad();
  // @@protoc_insertion_point(field_mutable:root.ecad)
  return _msg;
}
inline void root::set_allocated_ecad(::Ecad* ecad) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ecad_;
  }
  if (ecad) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ecad);
    if (message_arena != submessage_arena) {
      ecad = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecad, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ecad_ = ecad;
  // @@protoc_insertion_point(field_set_allocated:root.ecad)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GeneralType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GeneralType>() {
  return ::GeneralType_descriptor();
}
template <> struct is_proto_enum< ::Units> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Units>() {
  return ::Units_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_test_2eproto
