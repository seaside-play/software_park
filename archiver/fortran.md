## 1 基础 ##

integer a !这是声明一个名字为a的整形变量

integer,parameter :: N = 300  !这里的parameter表明这个变量是个常量，而且上一行声明的变量是不能直接赋值的，但是我们加个：：之后就可以赋值了

integer(kind=4)a  !这里的kind表明用多少个字节来存放整数a，常用的有 1，2，4，8；如果要表示的数太大，字节不够放的这时候就会出现错误，所以我们经常使用一个函数 k=Selected_Int_kind(i)  i表示需要的最大的十进制位数，k表示返回的能满足范围的最小的kind值。同理其他的类型的变量也可以用kind来声明位数，real常见的有4，8，16等 k=Selected_Real_Kind(r,p)  r表示需要返回的最大的十进制位数，p表示最小的有效位数，k表示能返回的满足范围的最小的kind值

complex(kind=4) a
a=(x,y) !x表示实部，y表示虚部

character(len=10) a !a表示我们的字符串a可以放10个字符


### 1.1 数组 ###

integer a(10) !最简单的方法
integer,dimension(10):a !另一种方法
integer a ! 这是fortran77的做法，先声明a是整数
dimension a(10) !再声明a是大小为10的数组

数组除了4种基本类型：integer, real, logical, complex, 还可以自定义类型使用type（就像C中的struct一样）

fortran数组是下标是从1开始的

另外的定义二维数组的方法：

integer a(10, 10) ! 最简单的表示方法
integer, dimension(10, 10) :: a ! 另一种方法
integer a !fortran77的做法，先声明a是整数
dimension a(10, 10) ! fortran 77 再声明a是长度为10的数组

二维数组经常被拿来当成矩阵使用

write(*, "('A(',I1, ',', I1, ')=')") ! 这里的I表示依次代表后边的变量，而I之后的数字表示变量会占用的字符个数

多维数组

integer a(D1, D2, ..., Dn) !n 维数组
a(I1, I2, ..., In) !使用n维数组时，要给n个坐标值

为所谓的多维数组，就是对键值对的不断递归的概念，没有什么新奇的。

在没有特别赋值的情况下看，数组的索引值都是从1开始的。如integer a(5),分别为a(1)... a(5)  
也可特别声明的方法改变默认的规则，在声明时，可以给定数组的坐标值使用范围，如：integer a(0:5), 这样数据就能使用a(0)，且有6个元素啦

事实上，一维，二维和多维都可以改变下标的取值范围，很灵活。

### 1.2 数组赋初值 ###

使用DATA来设置数组的初值，如：  
integer a(5)  
data a /1,2,3,4,5/  
data a /5*3/ 5个3，使用`*`来表示  
data(a(I), I = 2, 4) /2, 3, 4/ !初始化a(2), a(3), a(4) 为2 ，3， 4。a(1) and a(5)没有设定，使用了隐式循环。 

循环， 用圆括号括起来，指定变量名和索引值，再对索引值进行范围给定，如(a(I), I = 2, 4)

fortran90可以省略data描述，直接设置初值
integer :: a(5) = (/ 1,2,3,4,5 /) !注意括号跟除号不能有空格
integer :: a(5) = (/ 1,(2, I=2,4),5 /) !注意括号跟除号不能有空格

fortran90 隐含式循环的功能可以更强大

/ 斜杠为fortran中的换行符

### 1.3 对整个数组的操作 ###

Fortran90语法添加了许多设置数组内容的方法
[a=5] !将数组a的内容全部设置为5，不用循环啦  
[a=(/ 1,2,3,4 /)] ! 右边提供的数据长度必须和数组a的长度一致  
[a=b+c]  同位置相互操作
[a=b*c]
[a=b-c]
[a=sin(b)] 矩阵a的每一个元素为矩阵b元素的sin值，数组b必须是浮点数类型，才能使用sin函数。以一维来说，这个命令得到的结果是：a(i) = sin(b(i))

[a=b>c] a为逻辑数组

### 1.4 对部分数组的操作 ###

除了一次对整个数组进行操作外，也提供一次只挑出部分数组来操作的功能。
[a(3:5)=5]
[a(3:)=5]
[a(3:5)=(/ 3,4, 5/)]
[a(1:3)=b(4:6)]
[a(1:5:2)=3]  a(1)=a(3)=a(5)=3
[a(1:10)=a(10:1:-1)]     ! 这些操作与python中的自动推导是一个概念, 内容翻转
[a(:)=b(:, 2)] ! a为一维数据，如a(5), b为二维数据，是说将第二列的数据都给a数组

要拿数组中一部分内容来使用，只要把握两个原则：
（1）等号两边所使用的数组元素数目要一样多；
（2）同时使用多个隐含式循环时，较低维的循环可以想象成是内层的循环，用一个实例来说明这个原则：


### 1.5 where ###  

where是Fortran 95添加的功能，它也是用来取出部分数组内容进行设置，它与通过数组坐标值使用部分元素，where可以经过逻辑判断来使用数组的一部分元素，实例： where有点像if，可以对数组元素中所有符合逻辑要求的元素，都筛查出来。

where是用来设置数组的，所以它在程序模块中只能出现于设置数值相关的命令，同时必须是相同维数及大小的数组。

where可以嵌套，也跟循环一样可以去名字，不够取名的where描述在结束时end where 后面要接上它的名字

name: where (a < 5)
  b = a
end where name

### 1.6 forall ###

是fortran95添加的功能，简单来说，可以看成一种使用隐含式循环来使用数组的方法，不过它的功能可以做得更强大。

### 1.7 数组的保存规则 ###

还有一些关于数组的概念应该要了解，才能在写程序时使用一些特别的技巧，这些概念可以应该在传递数组数据到子程序中，还可以应用在程序的优化上，编写出效率比较高的程序。

多维数组的元素，，在内存的连续模块中排列情况是一种称为“Column Major”的方法来排列的。
如 integer a(3,3),在内存中放置9个元素为：a(1,1)->a(2,1)->a(3,1)->a(1,2)->a(2,2)-> ...-> a(2,3)->a(3,3)
Column Major的意义引申到多维数组时，会先放入低维的元素，再放入高维的元素。 ！维越小的使用越内层的循环

### 1.8 动态数组 ###
Fortran90的数组，可根据需求来实时决定它的大小。

integer, allocatable :: a(:)
integer :: i
i = 10
allocate(a(i), stat=error) ! 分配空间,加上stat的文本框来得知内存配置是否成功，error是事先声明好的整型变量，做allocate这个动作时，会经由stat这个叙述传给error一个数值，若error等于0，表示allocate数组成功，而如果error不等于0，表示allocate数组失败。

allocated(a) ! 用来检查一个可变大小的矩阵是否已经配置内存来使用，它会返回一个逻辑值
if (.not. allocated(a)) then
  allocate(a(5))
end if

deallocate


- 矩阵乘法
  - matmul: c = matmul(a, b) ! 可以实现矩阵a*b的功能matmul是一个fortran内部调用函数


## 2. 函数 ##

函数是自定义函数和子程序的统称。
- 子程序可以用来独立出某一段具有特定功能的程序代码，供其他地方调用。
- 自定义函数可用来自由扩充出fortran库函数中原来不存在的函数。subroutine

自定义函数的功能更加单一性，而子程序的逻辑更加完整完备。

### 2.1子程序 subroutine ###

以后经过调用call命令，就可以执行一段程序代码

在子程序中使用return以便随时返回调用函数。 子程序可以在程序的任何地方被别人调用，甚至可以自己调用自己，成为“递归”。不过Fortran77并不允许递归的操作，而Fortran90可以。

子程序独立地拥有属于自己的变量声明。 简单来说，主程序和子程序时两种不同的“程序”，不同程序之间可以各自独立拥有属于自己的变量声明及自己的行代码定义。还可以“传递参数”


Fortran在传递参数时，使用的是传址调用（call by address/call b y reference），这个意思是说调用时所传递出去的参数，和子程序中接受的参数，它们`会使用相同的内存地址来记录数据`。

Fortran库函数的三角函数都使用弧度

### 2.2 自定义函数（function） ###

和子程序只有两点不同：
1. 调用自定义函数前要先声明；
2. 自定义函数执行后会返回一个数值；

子程序的返回值只能从参数中返回，而自定义函数执行后会返回一个数值

函数如果很简短，又只会在同一个主程序或是函数中被使用，可以用下面的方法（lambda的思想）

- 不成文的规定，**重点** 
  - 传递给函数的参数，只要读取它的数值就好，不要去改变它的数据。从数学意义上将，输入函数中的参数时所谓的“自变量”，而函数返回值是“应变量”
  - 如果要修改输入的参数，最好使用子程序，而不是使用函数来完成这个工作


### 2.3 全局变量(common) ###

全局变量，让不同程序中声明出来的变量使用相同的内存位置，这是在不同程序间传递数据的另一种方法。

要设置全局变量的初值有另外的方法，不能使用**data**的命令来设置它们的初值。

取用全部变量时，是根据它们声明时的相对位置来做对应，而不是使用变量名称来对应的。因为a,num1都是common中的第一个变量，它们使用相同的内存位置，b、num2都是common中的第2个变量。

全局变量都使用相同的内存位置，所以程序中的每个函数中都可以察觉到全局变量值的改变。全局变量是使用**地址对应**的方法在程序中共享数据的。

好方法：把变量归类放在彼此独立的**common**区间内。就是命名空间


传递参数与使用全局变量都可以使用在不同的程序之间共享数据，那什么时候使用参数，什么时候使用全局变量？
1. 当需要共享的变量不多，且只有少数的几个程序需要使用这些数据时，使用参数；
2. 需要共享大笔数据，或者有很多个不同程序都需要使用这些数据，使用全局变量；

### 2.3 blockdata ###
用来初始化common变量，即设置初值，要在block data程序模块中使用data命令来设置初值。在主程序执行前就会生效，不过它的功能只在于设置全变量的初值，不能有其他执行命令出现。

全局变量不能声明成常量，所以block data中不能出现parameter

**[注意]**把握全局变量使用相同内存空间的策略.使用common时,编译器并不会帮忙做类型检查工作,由程序员自行负责.


fortran90 有另一种方法使用全局变量,可避免当全局变量类型变化时带来的众多调用处类型修改的麻烦问题.

### 函数中的变量

参数传递的技巧,注意事项及参数的“生命周期”

#### 传递参数的注意事项

- 是指针传递，类型要正确
- 使用浮点数要记得加小数点
- 数组参数： 数组会占据一块内存中的连续空间，在传递数组参数时，实际上是传递数组元素当中的某一个内存地址，把握这个原则，可有很多技巧。
- 数组在声明时要使用变量来赋值它的大小，不过在函数中，如果数组时接收用的参数时，可以是例外。这时可用变量来赋值大小，甚至可以不去赋值大小。
  - integer :: num(*) ! 表示不指定大小，只要不越界，想用多少就用多少。不赋值数组大小，还可以重新定义数组坐标范围，如：
  - integer :: num(-2, 2)
  - 使用 **subroutine** 来传递数组哦！就是一个子集嘛
- 传递字符串变量时，也可以不特别赋值它的长度，原因相同，因为它的长度早就设置好了
  - charactor(len=*)string !表示字符串长度在此不定。
- 变量生命周期
  - 函数运行完成，变量（非参数）会消亡，除非使用 **save**会记住上一次函数调用时被设置的值，就像 c++中的static一样.
    - integer, save :: count = 1
- 传递函数
  - 传递数字，字符串等数据之外，还可以把一个函数名称当成参数传送出去
    - external：表示自定义函数 real, external :: f ! 声明func是自定义函数
    - intrinsic：表示库 函数   real, intrinsic :: sin ! 声明sin是库函数
  - 子程序也可以拿来作为参数传递出去
    - external sub1，sub2 ！声明sub1、sub2是子程序名称
  - 以上两种的传递方法类似于C语言中的函数指针
- 特色参数的使用方法
  - Fortran 90，还可以赋值参数的属性，设置某些参数时只读不能改变，还可以输入不定个数的参数，还可以不按照顺序来传递参数
    - 只读：使用intent
      - integer,intent(in) :: a  !指定只读
      - integer,intent(out) :: b ! 指定b在子程序中应该重新设置数值

- 函数的使用接口（interface）
  - 用来说明调用函数的参数类型及返回值类型等等的“使用接口”，在如下情况下是必要的：
    - 函数返回值为数组，指针时
    - 指定参数位置来传传递参数
    - 输入指标参数时
    - 所调用的函数参数数目不固定时
  - 声明使用接口，对程序员来说，是一个很麻烦的工作，尤其需要调用多个函数时，整个程序看起来很烦杂。使用module可以减少这个麻烦。
  
### 特殊的函数类型
- 递归：
    - 函数开头使用关键字**recursive**，表示这个子程序可以递归来杯自己调用
      - recursive integer function fact(n) result(ans) !用ans来代替原来的fact，使用关键result来修改返回值名字
      - Fortran90中必须使用return来改变返回值
      - 若没有recursive时，不能够知己诶用递归来调用自己，但可用迂回的方法来实现递归，就是在函数中调用别的函数，再 经过那个函数来调用自己。“间接递归”

### 内部函数
Fortran 90 还可以把函数做一个“归属”，定义出某些函数只能在某些特定的函数中被调用。

### PURE函数
一般情况下不使用pure函数，它是用来配合并行运算使用的，使用pure函数时有很多限制。
### elemental函数
在function/subroutine之前加上elemental，就可使用elemental类型函数，也可以用来做并行运算，同样有pure函数的6项限制。


### module
可用来封装程序模块，通常是用来把程序中，具备相关功能的函数和变量封装在一起。

举例来说，需要使用全局变量时，可以把全局变量都声明在module中，需要使用这个变量的函数只要use这个module就可以使用它们啦

module中的变量如不是声明全局变量，这些变量被函数使用时，只会是函数中的局部变量。若想让函数之间通过module中的变量传递变量，要把变量声明成全局变量，或在声明变量时加上save。在module声明中指定save的变量，功能上也等于全局变量。那有什么区别呢？

#### module中的自定义类型type

使用自定义类型可以减少参数的数目，就是C中的struct结构体的含义。

函数使用前需要进行external声明，而子过程不需要声明，可以直接使用。

module中还可以容纳函数，如：

 module module_name
  contains
    subroutine sub_name
      ...
    end subroutine 

    function func_name
      ...
    end 
 end

通常会把**功能上相关的函数**放在同一个module模块中，而程序想要调用module中的函数时，也要通过 use module_name的命令，才能够调用到它们。这个做法比较符合模块化概念，编写大程序时，把程序中数据绘图功能的部分放在 module Graphics中，把数值计算的部分放在module Numerical中。就像C++中的类的概念一样，当然要比类简单，只能说是最为原始的概念。

fortran中提供的一些扩展函数库就用该方法，如数值函数库IMSL就放在module IMSL， 3D绘图程序库OpenGL的函数就放在module OpenGL中。使用它们之前就要先use IMSL、use OpenGL

在同一个module中的变量基函数间还有一个很重要的关系，那就是函数可以直接使用同一个module里所声明的变量，如下：

  module tool
    implicit none
    integer :: a
    ...
    ...
    contains
     subroutine add()
     implicit none
     ... 
     a = a + 1
     ...

关于这个功能，会涉及到一些面向对象的概念。很容易理解哈，module就像关键字class，当然比class要简单多了。而type就像简单版本的struct。
在module中所使用的module（use module_name），访问属性是public哦，同时use module_name又像是命名空间，一旦声明了use module_name，它内部的变量和函数都可以在当前函数中使用啦。

使用module shoot注意两点：
1. module shoot已包含constant和typedef这两个module，所以在module shoot里面的函数可以直接看到constant和typedef这两个module里面的内容；
2. 封装在同一个module中的函数会自动互相认识，不需要声明外部函数就直接使用函数；


### 8.8 一些少用的功能

- entry
  - 用来在函数中创建一个新的“入口”，调用这个入口时，会跳过进入点之前的程序代码来执行函数。这个功能很强大，可以将一个超级大的函数分拆成几个小的函数，但是从结构上来看，还是不够具有独立性，因为进入某一个跳跃点之后，下面的函数都是要执行的，同时还要考虑变量的有效性等。在非常时期，估计有很大的用处吧 

- return
  - 就是随时可以返回，在C++中那是在普通不过的，由于选择返回。