## _cdecl与_stdcall
- _cdecl
 是C Declaration的缩写，表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数无需要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。

- _stdcall
是Standard Call的缩写，是C 的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。这些堆栈中的参数由被调用的 函数在返回后清除，使用的指令是 retn X，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的 控制参数的生成，不能多，不能少，否则返回后会出错。

C中不加说明默认函数为_cdecl方式（C中也只能用这种方式），C也一样，但是默认的调用方式可以在IDE环境中设置。
带有可变参数的函数必须且只能使用_cdecl方式

- 两者之间的区别：

1. WINDOWS的函数调用时需要用到栈（STACK，一种先入后出的存储结构）。当函数调用完成后，栈需要清除，这里就是问题的关键，如何清除？？
如果我们的函数使用了_cdecl，那么栈的清除工作是由调用者，用COM的术语来讲就是客户来完成的。这样带来了一个棘手的问题，不同的编译器产生栈的方式不尽相同，那么调用者能否正常的完成清除工作呢？答案是不能。
如果使用__stdcall，上面的问题就解决了，函数自己解决清除工作。所以，在跨（开发）平台的调用中，我们都使用__stdcall（虽然有时是以WINAPI的样子出现）。

2. 那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用_cdecl。
到这里我们有一个结论，如果你的程序中没有涉及可变参数，最好使用__stdcall 关键字

不管__cdecl，还是__stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字，后面再跟返回类型，再后面是参数表的开始标识和按照参数类型代号拼出的参数表，参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。
如 double add(double a, double b) 被修饰为 ?add@@YANNN@Z 。
对于__stdcall方式，参数表的开始标识是“@@YG”，对于__cdecl方式则是“@@YA”。

X--void
D--char
E--unsigned char
F--short
H--int
I--unsigned int
J--long
K--unsigned long（DWORD）
M--float
N--double
_N--bool
U--struct