
改几行代码，for循环耗时从3.2秒降到0.3秒
# 1 循环展开
## 1.1 灵魂拷问
- 循环展开为什么能提高程序性能，其背后的深层原理是什么？
- 循环随便怎么展开都一定可以提高性能吗？不一定
- 用了优化选项，编译器一定会帮我们自动进行循环展开优化吗？不一定

# 2 背景知识
## 2.1 CPU内部架构
### 2.1.1 指令流水线（Pipeline）
所谓**流水线**，是指把指令的执行过程分成多个阶段，每个阶段使用CPU内部不同的硬件资源来完成。以经典的5级流水线为例，一条指令的执行被分成5个阶段。

1. 取指（IF）：从内存中取出一条指令；
2. 译码（ID）：对指令进行解码，确定该指令要执行的操作；
3. 执行（EX）：执行该指令要执行的操作；
4. 访存（MEM）：进行内存访问操作；
5. 写回（WB）：把执行的结果写回寄存器或内存；

在一个5级流水线中，理想情况下，可以有5条不同的指令的不同阶段在**同时执行**，因此，每个时钟周期都会有一条指令完成执行，从而大大提高CPU执行指令的吞吐率，从而提高CPU整体性能。这就叫做**ILP-指令级并行（Instruction Level Parallelism）**

通过将指令执行分为多个阶段，CPU每个时钟周期只处理一个阶段的工作，可大大简化CPU内部负责每个阶段的功能单元，每个时钟周期做的事情少，提高时钟频率也会变得简单。

以上就是**流水线技术**的介绍，那在流水线技术的前提下，能否让CPU在每个时钟周期内，完成多条指令的执行吗？这样就会进一步大大提升CPU整体性能。那就是**超标量（Superscalar）技术**。

### 2.1.2 超标量（Superscalar）
所谓**超标量**，是一种CPU架构，就是通过在CPU内部实现**多条指令流水线**，可以真正实现**在单个时钟周期内**并行执行多条指令，也被称为**多发射数据通路技术**。

以**双发射流水线**为例，每个时钟周期，CPU可以同时读取两条指令，然后同时对两条指令进行译码，同时执行，同时访存，然后同时写回。

到目前为止，一切看起来很完美，然而现实往往没有理想那么丰满。

### 2.1.3 流水线冲突
现实中程序中的指令序列之间往往存在各种各样的依赖和相关性，而CPU为了解决这种指令间的依赖和相关性，有时候不得不“**停顿**”下来，直到这些依赖得到解决，这就导致CPU指令流水线无法总是保持“**全速运行**”。

这种现象称之为**Pipleline Hazard**，很多资料翻译为“**流水线冒险（遭受危险）**”，我觉得“**流水线冲突**”更为贴切易懂。

流水线冒险意味着流水线不能正常流水，而需要截断停止，直到等待另一个指令完成之后，截流部分才能继续流动，这样使正常的流水线遭受到了危险。故**流水线冒险**更加贴切。

具体的冒险（冲突）有：
- 数据冲突（Data Hazard）
- 控制冲突（Control Hazard）
- 结构冲突（Structure Hazard）
