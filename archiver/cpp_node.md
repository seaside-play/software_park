- 运算效率
  
  `移位 > 赋值 > 大小比较 > 加法 > 减法 > 乘法 > 取模 > 除法`

- binary_search()

需要注意的是，由于 binary_search() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。所谓“已排好序”，并不是要求 [first, last) 区域内的数据严格按照某个排序规则进行升序或降序排序，`只要满足“所有令 element<val（或者 comp(val, element）成立的元素都位于不成立元素的前面（其中 element 为指定范围内的元素）”即可。`

那么就意味着，在默认情况下，comp中的lhs参数是所有element中的最大值。

关联容器将以下算法函数列为成员函数，也可单独使用，而顺序容器则需要`algorithm`来执行
`binary_saerch()` , `equal_range`, `lower_bound`, `upper_bound` 


`lower_bound`: 用于在有序序列中查找第一个大于或等于给定值的元素，并返回该元素的迭代器。

ower_bound是一个非常有用的函数，它在许多不同的使用场景中都可以发挥出其强大的作用。以下是一些常见的使用场景：

1. 二分查找：lower_bound函数实际上是一种改进的二分查找算法的实现，可以用来在一个有序序列中查找第一个大于或等于给定值的元素。这种查找操作在需要快速定位某个元素的位置时非常有用。

2. 数组排序：如果你有一个未排序的数组，但你知道它需要按照某种顺序排列，lower_bound可以帮助你快速找到应该放在某个特定位置的元素。你可以使用lower_bound来找到插入位置，这样就可以在保持数组排序的情况下插入新元素。

3. 在有序集合中插入元素：如果你正在使用像std::set或std::map这样的有序集合，那么你可能需要找到一个插入新元素的位置。lower_bound可以用来找到应该插入新元素的位置。

4. 查找满足特定条件的第一个元素：如果你有一个序列，并且你想找到第一个满足特定条件的元素，那么lower_bound可以帮助你快速找到它。例如，你可以使用lower_bound来找到第一个大于或等于给定值的元素。

5. 在大数据中查找元素：lower_bound的时间复杂度为O(log n)，对于大数据量的查找操作，其效率远高于线性查找。因此，在大数据集中查找元素时，lower_bound是一种非常有效的工具。
  以上就是一些常见的lower_bound的使用场景，实际上它的应用非常广泛，几乎可以在任何需要二分查找的场景中使用它。

6. 数据库查询优化：在数据库查询中，如果你需要找到某个值的第一个匹配项，lower_bound可以帮助你快速定位。这可以避免全表扫描，提高查询效率。

7. 在日志文件中查找错误：如果你正在处理一个包含大量日志的文本文件，并且你想找到第一个包含特定错误信息的行。你可以使用lower_bound来快速定位这个错误。

8. 在日志中查找异常：如果你正在分析一个包含大量数据的日志文件，并且你想找到第一个出现特定异常的记录。lower_bound可以帮助你快速找到这个异常。

9. 二分搜索算法的实现：lower_bound实际上是一种改进的二分查找算法的实现。如果你需要实现一个二分搜索算法，那么可以使用lower_bound函数作为你的查找策略。

10. 在游戏AI中查找路径：如果你正在开发一个游戏，并且你需要AI角色找到从起点到终点的最快路径。你可以使用lower_bound来找到最接近终点的位置，然后再向终点方向搜索。